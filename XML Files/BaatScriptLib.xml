<?xml version="1.0" encoding="Windows-1252" standalone="no"?>
<RefData version="1.0" exporter="EA.25">
	<DataSet name="Automation Scripts" table="t_script" filter="ScriptName='#ScriptName#' and ScriptCategory='#ScriptCategory#'" stoplist=";ScriptID;">
	<DataRow>
			<Column name="ScriptID" value="14" />
			<Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782" />
			<Column name="ScriptName" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Group Type=&quot;NORMAL&quot; Notes=&quot;&quot;/&gt;" />
			<Column name="Script" value="BaatScriptLib" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="15" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{411C40ED-8A05-4abf-BAFF-6F8BED0367F4}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;ImExExportConnectorsJAVA&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatPackageScripts]&#xA;!INC Local Scripts.EAConstants-JavaScript&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;!INC EAScriptLib.JavaScript-Dialog&#xA;!INC EAScriptLib.JavaScript-XML&#xA;!INC BaatScriptLib.JavaScript-Connector&#xA;!INC BaatScriptLib.JavaScript-EXCEL&#xA;!INC BaatScriptLib.JavaScript-ImEx&#xA;&#xA;/*&#xA; * This code has been included from the default Project Browser template.&#xA; * If you wish to modify this template, it is located in the Config\Script Templates&#xA; * directory of your EA install path.   &#xA; * &#xA; * Script Name:&#x9;ImExExportConnectorsJAVA&#xA; * Author:&#x9;&#x9;J de Baat&#xA; * Purpose:&#x9;&#x9;Export the information from Connectors in the selected Package or Diagram&#xA; * Date:&#x9;&#x9;13-07-2024&#xA; * &#xA; * Note:&#x9;    Open Excel file for writing contents&#xA; */&#xA;&#xA;/*&#xA; * Handle the Excel Application and the WorkSheet to export data to&#xA; */&#xA;function ImExExportConnectors( )&#xA;{&#xA;&#xA;&#x9;// Initialize the EXCEL Export session with the sheet and columns&#xA;&#x9;let curHandleExcelExportResult = IMEXEHandleExcelExport( strDefaultConnectorsSheetName );&#xA;&#x9;return curHandleExcelExportResult;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Export the Connectors of the Elements found in this Package&#xA; */&#xA;function ImExExportPackageObjects()&#xA;{&#xA;&#x9;let curNumConnectors = 0;&#xA;&#xA;&#x9;curNumConnectors = ProcessPackage( objGlobalEAPackage, 0 );&#xA;&#x9;Session.Output(&quot;ImExExportPackageConnectors Processed objGlobalEAPackage( &quot; + objGlobalEAPackage.Name + &quot; ) and newNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Export the Connectors of the Elements found in this Diagram&#xA; */&#xA;function ImExExportDiagramObjects()&#xA;{&#xA;&#x9;let curNumConnectors = 0;&#xA;&#xA;&#x9;curNumConnectors = ProcessDiagram( objGlobalEADiagram, 0 );&#xA;&#x9;Session.Output(&quot;ImExExportDiagramConnectors Processed objGlobalEADiagram( &quot; + objGlobalEADiagram.Name + &quot; ) and newNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Initialize the EXCEL Export columns for Connectors&#xA; */&#xA;function ImExGetStandardObjectColumns()&#xA;{&#xA;&#xA;&#x9;// Initialize the EXCEL Export columns for Connectors&#xA;&#x9;let curExportColumns = IMEXEGetStandardConnectorColumns();&#xA;&#x9;return curExportColumns;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process theElement provided as parameter and its Connectors&#xA; */&#xA;function ProcessElement( theElement, theNumConnectors )&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var curElement           as EA.Element;&#xA;&#x9;var curElementConnector  as EA.Connector;&#xA;&#x9;var curElementConnectors as EA.Collection;&#xA;&#x9;let curNumConnectors;&#xA;&#x9;let newNumConnectors;&#xA;&#xA;&#x9;curElement       = theElement;&#xA;&#x9;curNumConnectors = theNumConnectors;&#xA;&#xA;&#x9;if ( curElement == undefined ) {&#xA;&#x9;&#x9;return theNumConnectors;&#xA;&#x9;}&#xA;&#xA;&#x9;// Process all curElementConnectors in curElement&#xA;&#x9;curElementConnectors = curElement.Connectors;&#xA;&#x9;for ( let i = 0 ; i &lt; curElementConnectors.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curElementConnector = curElementConnectors.GetAt( i );&#xA;&#x9;&#x9;// newNumConnectors    = ProcessConnector( curElementConnector, curNumConnectors );&#xA;&#x9;&#x9;// curNumConnectors    = newNumConnectors;&#xA;&#x9;&#x9;// Session.Output(&quot;ProcessElement Processed curElementConnectors(&quot; + i + &quot;) of [&quot; + curElementConnectors.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;// Build the curConnectorMap with values to Export&#xA;&#x9;&#x9;let curConnectorMap = IMEXEGetStandardConnectorFieldValues( curElement, curElementConnector );&#xA;&#xA;&#x9;&#x9;// Export the Connector of this Element&#xA;&#x9;&#x9;if ( curConnectorMap == strNoClientConnector ) {&#xA;&#x9;&#x9;&#x9;// Session.Output( &quot;ProcessElement curConnectorMap found NoClientConnector (i.e. duplicate) for ElementID &quot; + curElement.ElementID + &quot; and Connector.ClientID &quot; + curElementConnector.ClientID + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;// LOGWarning( &quot;ProcessElement curConnectorMap found NoClientConnector (i.e. duplicate) for ElementID &quot; + curElement.ElementID + &quot; and Connector.ClientID &quot; + curElementConnector.ClientID + &quot;!&quot; );&#xA;&#x9;&#x9;} else {&#xA;&#xA;&#x9;&#x9;&#x9;// Export the Connector of this Element&#xA;&#x9;&#x9;&#x9;if ( curConnectorMap != null ) {&#xA;&#x9;&#x9;&#x9;&#x9;EXCELEExportRow( curConnectorMap );&#xA;&#x9;&#x9;&#x9;&#x9;curNumConnectors++;&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;ProcessElement Processed curConnectorMap for ElementID &quot; + curElement.ElementID + &quot; and Connector.ClientID &quot; + curElementConnector.ClientID + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;ProcessElement could NOT get curConnectorMap for ElementID &quot; + curElement.ElementID + &quot; and Connector.ClientID &quot; + curElementConnector.ClientID + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Clean up memory&#xA;&#x9;&#x9;curConnectorMap  = null;&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curElementConnector  = null;&#xA;&#x9;curElementConnectors = null;&#xA;&#xA;&#x9;// Session.Output(&quot;ProcessElement Processed Element(&quot; + curElement.Name + &quot;) with ObjectType(Type)=&quot; + curElement.Type + &quot;, Connectors.Count=[&quot; + curElement.Connectors.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumConnectors;&#xA;}&#xA;&#xA;/*&#xA; * Process thePackage provided as parameter and its Elements and SubPackages&#xA; */&#xA;function ProcessPackage( thePackage, theNumConnectors )&#xA;{&#xA;&#xA;&#x9;// Cast thePackage to EA.Package so we get intellisense&#xA;&#x9;var curPackage         as EA.Package;&#xA;&#x9;var curPackageElements as EA.Collection;&#xA;&#x9;var curPackagePackages as EA.Collection;&#xA;&#x9;var curPackageElement  as EA.Element;&#xA;&#x9;var curPackagePackage  as EA.Package;&#xA;&#x9;let curNumConnectors;&#xA;&#x9;let newNumConnectors;&#xA;&#xA;&#x9;curPackage       = thePackage;&#xA;&#x9;curNumConnectors = theNumConnectors;&#xA;&#xA;&#x9;// Process all Elements in curPackage&#xA;&#x9;curPackageElements = curPackage.Elements;&#xA;&#x9;for ( let i = 0 ; i &lt; curPackageElements.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curPackageElement = curPackageElements.GetAt( i );&#xA;&#x9;&#x9;newNumConnectors  = ProcessElement( curPackageElement, curNumConnectors );&#xA;&#x9;&#x9;curNumConnectors  = newNumConnectors;&#xA;&#x9;&#x9;// Session.Output(&quot;ProcessPackage Processed curPackageElement(&quot; + i + &quot;) of [&quot; + curPackageElements.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curPackageElement  = null;&#xA;&#x9;curPackageElements = null;&#xA;&#xA;&#xA;&#x9;// Process all subPackages in curPackage&#xA;&#x9;curPackagePackages = curPackage.Packages;&#xA;&#x9;// Session.Output(&quot;ProcessPackage Starting recursively for Package(&quot; + curPackage.Name + &quot;) with curPackagePackages.Count=[&quot; + curPackagePackages.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#x9;for ( let i = 0 ; i &lt; curPackagePackages.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curPackagePackage = curPackagePackages.GetAt( i );&#xA;&#x9;&#x9;newNumConnectors  = ProcessPackage( curPackagePackage, curNumConnectors );&#xA;&#x9;&#x9;curNumConnectors  = newNumConnectors;&#xA;&#x9;&#x9;// Session.Output(&quot;curPackagePackage(&quot; + curPackagePackage.Name + &quot;) with Elements.Count=[&quot; + curPackagePackage.Elements.Count + &quot;] and Packages.Count=[&quot; + curPackagePackage.Packages.Count + &quot;] !!!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curPackagePackage  = null;&#xA;&#x9;curPackagePackages = null;&#xA;&#xA;&#x9;Session.Output(&quot;ProcessPackage Processed Package(&quot; + curPackage.Name + &quot;) with Elements.Count=[&quot; + curPackage.Elements.Count + &quot;], Packages.Count=[&quot; + curPackage.Packages.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumConnectors;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process theDiagram provided as parameter and its Elements&#xA; */&#xA;function ProcessDiagram( theDiagram, theNumConnectors )&#xA;{&#xA;&#xA;&#x9;// Cast theDiagram to EA.Diagram so we get intellisense&#xA;&#x9;var curDiagram        as EA.Diagram;&#xA;&#x9;var curDiagramObjects as EA.Collection;&#xA;&#x9;var curDiagramObject  as EA.DiagramObject;&#xA;&#x9;var curDiagramElement as EA.Element;&#xA;&#x9;let curNumConnectors;&#xA;&#x9;let newNumConnectors;&#xA;&#xA;&#x9;curDiagram     = theDiagram;&#xA;&#x9;curNumConnectors = theNumConnectors;&#xA;&#xA;&#x9;// Process all Elements in curDiagram&#xA;&#x9;curDiagramObjects = curDiagram.DiagramObjects;&#xA;&#x9;for ( let i = 0 ; i &lt; curDiagramObjects.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;// Get the curDiagramDiagramObject from the Collection&#xA;&#x9;&#x9;curDiagramObject = curDiagramObjects.GetAt( i );&#xA;&#xA;&#x9;&#x9;// Get the curDiagramElement using the curDiagramObject.ElementID&#xA;&#x9;&#x9;curDiagramElement = Repository.GetElementByID( curDiagramObject.ElementID );&#xA;&#x9;&#x9;if ( curDiagramElement != null ) {&#xA;&#x9;&#x9;&#x9;newNumConnectors = ProcessElement( curDiagramElement, curNumConnectors );&#xA;&#x9;&#x9;&#x9;curNumConnectors = newNumConnectors;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;ProcessDiagram Processed curDiagramElement(&quot; + i + &quot;) of [&quot; + curDiagramObjects.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curDiagramElement  = null;&#xA;&#x9;curDiagramElements = null;&#xA;&#xA;&#x9;Session.Output(&quot;ProcessDiagram Processed Diagram(&quot; + curDiagram.Name + &quot;) with DiagramObjects.Count=[&quot; + curDiagram.DiagramObjects.Count + &quot;] and curNumConnectors = &quot; + curNumConnectors + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumConnectors;&#xA;&#xA;}&#xA;&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="16" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{9AEB152D-5BF6-48fa-ABE0-C74269226DEB}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;ImExExportElementsJAVA&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatPackageScripts]&#xA;!INC Local Scripts.EAConstants-JavaScript&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;!INC EAScriptLib.JavaScript-Dialog&#xA;!INC EAScriptLib.JavaScript-XML&#xA;!INC BaatScriptLib.JavaScript-Connector&#xA;!INC BaatScriptLib.JavaScript-EXCEL&#xA;!INC BaatScriptLib.JavaScript-ImEx&#xA;&#xA;/*&#xA; * This code has been included from the default Project Browser template.&#xA; * If you wish to modify this template, it is located in the Config\Script Templates&#xA; * directory of your EA install path.   &#xA; * &#xA; * Script Name:&#x9;ImExExportElementsJAVA&#xA; * Author:&#x9;&#x9;J de Baat&#xA; * Purpose:&#x9;&#x9;Export the information from Elements in the selected Package or Diagram&#xA; * Date:&#x9;&#x9;13-07-2024&#xA; * &#xA; */&#xA;&#xA;/*&#xA; * Handle the Excel Application and the WorkSheet to export data to&#xA; */&#xA;function ImExExportElements( )&#xA;{&#xA;&#xA;&#x9;// Initialize the EXCEL Export session with the sheet and columns&#xA;&#x9;let curHandleExcelExportResult = IMEXEHandleExcelExport( strDefaultElementsSheetName );&#xA;&#x9;return curHandleExcelExportResult;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Export the Elements found in this Package&#xA; */&#xA;function ImExExportPackageObjects()&#xA;{&#xA;&#x9;let curNumElements = 0;&#xA;&#xA;&#x9;curNumElements = ProcessPackage( objGlobalEAPackage, 0 );&#xA;&#x9;Session.Output(&quot;ImExExportPackageElements Processed objGlobalEAPackage( &quot; + objGlobalEAPackage.Name + &quot; ) for NumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Export the Elements found in this Diagram&#xA; */&#xA;function ImExExportDiagramObjects()&#xA;{&#xA;&#x9;let curNumElements = 0;&#xA;&#xA;&#x9;curNumElements = ProcessDiagram( objGlobalEADiagram, 0 );&#xA;&#x9;Session.Output(&quot;ImExExportDiagramElements Processed objGlobalEADiagram( &quot; + objGlobalEADiagram.Name + &quot; ) for NumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Initialize the EXCEL Export columns for Elements&#xA; */&#xA;function ImExGetStandardObjectColumns()&#xA;{&#xA;&#xA;&#x9;// Initialize the EXCEL Export columns for Elements&#xA;&#x9;let curExportColumns = IMEXEGetStandardElementColumns();&#xA;&#x9;return curExportColumns;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process theTaggedValue provided as parameter&#xA; */&#xA;function ProcessTaggedValue( theTaggedValue, theNumElements )&#xA;{&#xA;&#x9;var curTaggedValue as EA.TaggedValue;&#xA;&#x9;let curNumElements;&#xA;&#xA;&#x9;curTaggedValue = theTaggedValue;&#xA;&#x9;// curNumElements = theNumElements + 1;&#xA;&#x9;curNumElements = theNumElements;&#xA;&#xA;&#x9;// Session.Output(&quot;ProcessTaggedValue Processed curTaggedValue(&quot; + curTaggedValue.Name + &quot;) with Value=[&quot; + curTaggedValue.Value + &quot;] and curNumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumElements;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process theElement provided as parameter and its TaggedValues&#xA; */&#xA;function ProcessElement( theElement, theNumElements )&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var curElement     as EA.Element;&#xA;&#x9;var curElementTag  as EA.TaggedValue;&#xA;&#x9;var curElementTags as EA.Collection;&#xA;&#x9;let curNumElements;&#xA;&#x9;let newNumElements;&#xA;&#x9;let curTagColumnArray = [];&#xA;&#xA;&#x9;curElement     = theElement;&#xA;&#x9;curNumElements = theNumElements + 1;&#xA;&#xA;&#x9;if ( curElement == undefined ) {&#xA;&#x9;&#x9;return theNumElements;&#xA;&#x9;}&#xA;&#xA;&#x9;// Process all curElementTags in curElement&#xA;&#x9;curElementTags = curElement.TaggedValues;&#xA;&#x9;for ( let i = 0 ; i &lt; curElementTags.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curElementTag  = curElementTags.GetAt( i );&#xA;&#x9;&#x9;newNumElements = ProcessTaggedValue( curElementTag, curNumElements );&#xA;&#x9;&#x9;curNumElements = newNumElements;&#xA;&#x9;&#x9;curTagColumnArray.push( strTaggedValuesPrefix + curElementTag.Name );&#xA;&#x9;&#x9;// Session.Output(&quot;ProcessElement Processed curElementTags(&quot; + i + &quot;) of [&quot; + curElementTags.Count + &quot;] and curNumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;// Add the TaggedValues to Export columns&#xA;&#x9;if ( curTagColumnArray.length &gt; 0 ) {&#xA;&#x9;&#x9;EXCELEAddExportColumns( curTagColumnArray );&#xA;&#x9;}&#xA;&#xA;&#x9;// Build the curValueMap with values to Export&#xA;&#x9;let curValueMap       = IMEXEGetStandardElementFieldValues( curElement );&#xA;&#x9;let curTaggedValueMap = IMEXEGetElementTaggedValues( curValueMap, curElement );&#xA;&#xA;&#x9;// Export the element&#xA;&#x9;EXCELEExportRow( curTaggedValueMap );&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curElementTag     = null;&#xA;&#x9;curElementTags    = null;&#xA;&#x9;curValueMap       = null;&#xA;&#x9;curTaggedValueMap = null;&#xA;&#xA;&#x9;// Session.Output(&quot;ProcessElement Processed Element(&quot; + curElement.Name + &quot;) with ObjectType(Type)=&quot; + curElement.Type + &quot;, TaggedValues.Count=[&quot; + curElement.TaggedValues.Count + &quot;] and curNumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumElements;&#xA;}&#xA;&#xA;/*&#xA; * Process thePackage provided as parameter and its Elements and SubPackages&#xA; */&#xA;function ProcessPackage( thePackage, theNumElements )&#xA;{&#xA;&#xA;&#x9;// Cast thePackage to EA.Package so we get intellisense&#xA;&#x9;var curPackage         as EA.Package;&#xA;&#x9;var curPackageElements as EA.Collection;&#xA;&#x9;var curPackagePackages as EA.Collection;&#xA;&#x9;var curPackageElement  as EA.Element;&#xA;&#x9;var curPackagePackage  as EA.Package;&#xA;&#x9;let curNumElements;&#xA;&#x9;let newNumElements;&#xA;&#xA;&#x9;curPackage     = thePackage;&#xA;&#x9;curNumElements = theNumElements;&#xA;&#xA;&#x9;// Process all Elements in curPackage&#xA;&#x9;curPackageElements = curPackage.Elements;&#xA;&#x9;for ( let i = 0 ; i &lt; curPackageElements.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curPackageElement = curPackageElements.GetAt( i );&#xA;&#x9;&#x9;newNumElements    = ProcessElement( curPackageElement, curNumElements );&#xA;&#x9;&#x9;curNumElements    = newNumElements;&#xA;&#x9;&#x9;// Session.Output(&quot;ProcessPackage Processed curPackageElement(&quot; + i + &quot;) of [&quot; + curPackageElements.Count + &quot;] and curNumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curPackageElement  = null;&#xA;&#x9;curPackageElements = null;&#xA;&#xA;&#xA;&#x9;// Recursively Process all subPackages in curPackage&#xA;&#x9;curPackagePackages = curPackage.Packages;&#xA;&#x9;// Session.Output(&quot;ProcessPackage Starting recursively for Package(&quot; + curPackage.Name + &quot;) with curPackagePackages.Count=[&quot; + curPackagePackages.Count + &quot;] and curNumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#x9;for ( let i = 0 ; i &lt; curPackagePackages.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;curPackagePackage = curPackagePackages.GetAt( i );&#xA;&#x9;&#x9;newNumElements    = ProcessPackage( curPackagePackage, curNumElements );&#xA;&#x9;&#x9;curNumElements    = newNumElements;&#xA;&#x9;&#x9;// Session.Output(&quot;curPackagePackage(&quot; + curPackagePackage.Name + &quot;) with Elements.Count=[&quot; + curPackagePackage.Elements.Count + &quot;] and Packages.Count=[&quot; + curPackagePackage.Packages.Count + &quot;] !!!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curPackagePackage  = null;&#xA;&#x9;curPackagePackages = null;&#xA;&#xA;&#x9;Session.Output(&quot;ProcessPackage Processed Package(&quot; + curPackage.Name + &quot;) with Elements.Count=[&quot; + curPackage.Elements.Count + &quot;], Packages.Count=[&quot; + curPackage.Packages.Count + &quot;] for NumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumElements;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process theDiagram provided as parameter and its Elements&#xA; */&#xA;function ProcessDiagram( theDiagram, theNumElements )&#xA;{&#xA;&#xA;&#x9;// Cast theDiagram to EA.Diagram so we get intellisense&#xA;&#x9;var curDiagram        as EA.Diagram;&#xA;&#x9;var curDiagramObjects as EA.Collection;&#xA;&#x9;var curDiagramObject  as EA.DiagramObject;&#xA;&#x9;var curDiagramElement as EA.Element;&#xA;&#x9;let curNumElements;&#xA;&#x9;let newNumElements;&#xA;&#xA;&#x9;curDiagram     = theDiagram;&#xA;&#x9;curNumElements = theNumElements;&#xA;&#xA;&#x9;// Process all Elements in curDiagram&#xA;&#x9;curDiagramObjects = curDiagram.DiagramObjects;&#xA;&#x9;for ( let i = 0 ; i &lt; curDiagramObjects.Count ; i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;// Get the curDiagramDiagramObject from the Collection&#xA;&#x9;&#x9;curDiagramObject = curDiagramObjects.GetAt( i );&#xA;&#xA;&#x9;&#x9;// Get the curDiagramElement using the curDiagramObject.ElementID&#xA;&#x9;&#x9;curDiagramElement = Repository.GetElementByID( curDiagramObject.ElementID );&#xA;&#x9;&#x9;if ( curDiagramElement != null ) {&#xA;&#x9;&#x9;&#x9;newNumElements = ProcessElement( curDiagramElement, curNumElements );&#xA;&#x9;&#x9;&#x9;curNumElements = newNumElements;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;ProcessDiagram Processed curDiagramElement(&quot; + i + &quot;) of [&quot; + curDiagramObjects.Count + &quot;] for NumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// Clean up memory&#xA;&#x9;curDiagramObjects = null;&#xA;&#x9;curDiagramObject  = null;&#xA;&#x9;curDiagramElement = null;&#xA;&#xA;&#x9;Session.Output(&quot;ProcessDiagram Processed Diagram(&quot; + curDiagram.Name + &quot;) with DiagramObjects.Count=[&quot; + curDiagram.DiagramObjects.Count + &quot;] for NumElements = &quot; + curNumElements + &quot;!!!&quot; );&#xA;&#xA;&#x9;return curNumElements;&#xA;&#xA;}&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="17" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{D43EEFA7-7B53-4508-A820-332F6AD3AC30}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;ImExImportConnectorsJAVA&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatPackageScripts]&#xA;!INC Local Scripts.EAConstants-JavaScript&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;!INC EAScriptLib.JavaScript-Dialog&#xA;!INC EAScriptLib.JavaScript-XML&#xA;!INC BaatScriptLib.JavaScript-Connector&#xA;!INC BaatScriptLib.JavaScript-EXCEL&#xA;!INC BaatScriptLib.JavaScript-ImEx&#xA;&#xA;/*&#xA; * This code has been included from the default Project Browser template.&#xA; * If you wish to modify this template, it is located in the Config\Script Templates&#xA; * directory of your EA install path.   &#xA; * &#xA; * Script Name:&#x9;ImExImportConnectorsJAVA&#xA; * Author:&#x9;&#x9;J de Baat&#xA; * Purpose:&#x9;&#x9;Import the information from Connectors into the selected Package&#xA; * Date:&#x9;&#x9;13-07-2024&#xA; * &#xA; */&#xA;&#xA;/*&#xA; * Handle the ExcelImport for importing Elements&#xA; */&#xA;function ImExImportConnectors( )&#xA;{&#xA;&#xA;&#x9;// Start the ExcelImport for this Import session&#xA;&#x9;// Session.Output(&quot;ImExImportElements started Excel.Application !&quot; );&#xA;&#x9;let strExcelImportResult = IMEXIHandleExcelImport( strDefaultConnectorsSheetName );&#xA;&#xA;&#x9;// Return the result found&#xA;&#x9;return strExcelImportResult;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process the Imported Connectors found&#xA; */&#xA;function OnExcelRowImported( theRow )&#xA;{&#xA;&#xA;&#x9;let actionResult = &quot;&quot;;&#xA;&#x9;let importAction = &quot;&quot;;&#xA;&#x9;let importRow    = 0;&#xA;&#xA;&#x9;if ( excelImportCurrentRow[0] != null ) {&#xA;&#x9;&#x9;importAction = excelImportCurrentRow[0].toLowerCase();&#xA;&#x9;}&#xA;&#x9;importRow = theRow;&#xA;&#x9;// Session.Output(&quot;OnExcelRowImported excelImportCurrentRow(&quot; + importRow + &quot;).length = &quot; + excelImportCurrentRow.length + &quot;, Action = &quot; + excelImportCurrentRow[0] + &quot;!!!&quot; );&#xA;&#xA;&#x9;// Process importAction requested&#xA;&#x9;switch( importAction )&#xA;&#x9;{&#xA;&#x9;&#x9;case &quot;create&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = createConnector();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;update&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = updateConnector();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;delete&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = deleteConnector();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = &quot;OnExcelRowImported found empty importAction!&quot;;&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Error message&#xA;&#x9;&#x9;&#x9;LOGError( &quot;OnExcelRowImported CANNOT process importAction &quot; + importAction + &quot;!&quot;  );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Update theConnector with information as provided&#xA; */&#xA;function createConnector()&#xA;{&#xA;&#xA;&#x9;var curConnector       as EA.Connector;&#xA;&#x9;var curElementClient   as EA.Element;&#xA;&#x9;var curElementSupplier as EA.Element;&#xA;&#xA;&#x9;// Find and process the element found by curConnectorGUID&#xA;&#x9;let curConnectorGUID = EXCELIGetColumnValueByName(&quot;CONNECTORGUID&quot;);&#xA;&#x9;curConnector         = GetConnectorByGuid( curConnectorGUID );&#xA;&#x9;if ( curConnector != null ) {&#xA;&#x9;&#x9;return &quot;createConnector( &quot; + curConnectorGUID + &quot; ) found curConnector.ConnectorID = &quot; + curConnector.ConnectorID + &quot; so skip creation to prevent duplicates!!!&quot; ;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;// Find and process the source element defined by Start_Object_ID&#xA;&#x9;&#x9;let curElementClientID = EXCELIGetColumnValueByName(&quot;Start_Object_ID&quot;);&#xA;&#x9;&#x9;curElementClient       = GetElementByID( curElementClientID );&#xA;&#x9;&#x9;if ( curElementClient == null ) {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so skip creation!!!&quot; );&#xA;&#x9;&#x9;&#x9;return &quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so skip creation!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Find and process the target element defined by End_Object_ID&#xA;&#x9;&#x9;let curElementSupplierID = EXCELIGetColumnValueByName(&quot;End_Object_ID&quot;);&#xA;&#x9;&#x9;curElementSupplier       = GetElementByID( curElementSupplierID );&#xA;&#x9;&#x9;if ( curElementSupplier == null ) {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so skip creation!!!&quot; );&#xA;&#x9;&#x9;&#x9;return &quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so skip creation!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// createConnector could NOT find curConnector so create new one&#xA;&#x9;&#x9;let curConnectorType = EXCELIGetColumnValueByName(&quot;Connector_Type&quot;);&#xA;&#x9;&#x9;// Session.Output(&quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector so create new one with Connector_Type &quot; + curConnectorType + &quot;!!!&quot; );&#xA;&#x9;&#x9;curConnector = CONSetElementConnector( curElementClient, curElementSupplier, curConnectorType, false );&#xA;&#xA;&#x9;&#x9;// createConnector created new curConnector so update it using the other values found&#xA;&#x9;&#x9;if ( curConnector != null ) {&#xA;&#xA;&#x9;&#x9;&#x9;// Process the updates for curConnector found&#xA;&#x9;&#x9;&#x9;let curResult = updateConnectorProperties( curConnector );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;createConnector( &quot; + curConnectorGUID + &quot; ) updated curConnector.Name to &quot; + curConnector.Name + &quot;, curResult= &quot; + curResult + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;return curResult;&#xA;&#xA;&#x9;&#x9;} else {&#xA;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT create curConnector so NOT updated!!!&quot; );&#xA;&#x9;&#x9;&#x9;return &quot;createConnector( &quot; + curConnectorGUID + &quot; ) could NOT create curConnector so NOT updated!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Update theConnector with information as provided&#xA; */&#xA;function updateConnector()&#xA;{&#xA;&#xA;&#x9;var curConnector       as EA.Connector;&#xA;&#x9;var curElementClient   as EA.Element;&#xA;&#x9;var curElementSupplier as EA.Element;&#xA;&#x9;var newElement         as EA.Element;&#xA;&#xA;&#x9;// Find and process the element found by curConnectorGUID&#xA;&#x9;let curConnectorGUID = EXCELIGetColumnValueByName(&quot;CONNECTORGUID&quot;);&#xA;&#x9;// Session.Output(&quot;updateConnector looking for curConnectorGUID: &quot; + curConnectorGUID + &quot;!!!&quot; );&#xA;&#x9;if ( curConnectorGUID == null ) {&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnector could NOT find curConnectorGUID: &quot; + curConnectorGUID + &quot; so skip update!!!&quot; );&#xA;&#x9;&#x9;return &quot;updateConnector could NOT find curConnectorGUID: &quot; + curConnectorGUID + &quot; so skip update!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;curConnector         = GetConnectorByGuid( curConnectorGUID );&#xA;&#x9;if ( curConnector != null ) {&#xA;&#xA;&#x9;&#x9;// Process the updates for curConnector found&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnector( &quot; + curConnectorGUID + &quot; ) found curConnector.Name = &quot; + curConnector.Name + &quot;, Visibility = &quot; + curConnector.Visibility + &quot;!!!&quot; );&#xA;&#x9;&#x9;let curResult = updateConnectorProperties( curConnector );&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnector( &quot; + curConnectorGUID + &quot; ) updated curConnector.Name to &quot; + curConnector.Name + &quot;, curResult= &quot; + curResult + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;// Find and process the source element defined by Start_Object_ID&#xA;&#x9;&#x9;let curElementClientID = EXCELIGetColumnValueByName(&quot;Start_Object_ID&quot;);&#xA;&#x9;&#x9;curElementClient       = GetElementByID( curElementClientID );&#xA;&#x9;&#x9;if ( curElementClient == null ) {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so skip update!!!&quot; );&#xA;&#x9;&#x9;&#x9;return &quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so skip update!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Check whether to Change the ClientID when Start_Object_ID changed&#xA;&#x9;&#x9;newElement = IMEXIGetNewConnectorStartOrEnd( curConnector, &quot;Start_Object_ID&quot;, curElementClient );&#xA;&#x9;&#x9;if ( newElement != null ) {&#xA;&#x9;&#x9;&#x9;curConnector.ClientID = newElement.ElementID;&#xA;&#x9;&#x9;&#x9;curConnector.Update();&#xA;&#x9;&#x9;&#x9;newElement.Update();&#xA;&#x9;&#x9;&#x9;curElementClient.Update();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Find and process the target element defined by End_Object_ID&#xA;&#x9;&#x9;let curElementSupplierID = EXCELIGetColumnValueByName(&quot;End_Object_ID&quot;);&#xA;&#x9;&#x9;curElementSupplier       = GetElementByID( curElementSupplierID );&#xA;&#x9;&#x9;if ( curElementSupplier == null ) {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so skip update!!!&quot; );&#xA;&#x9;&#x9;&#x9;return &quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so skip update!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Check whether to Change the SupplierID when End_Object_ID changed&#xA;&#x9;&#x9;newElement = IMEXIGetNewConnectorStartOrEnd( curConnector, &quot;End_Object_ID&quot;, curElementSupplier );&#xA;&#x9;&#x9;if ( newElement != null ) {&#xA;&#x9;&#x9;&#x9;curConnector.SupplierID = newElement.ElementID;&#xA;&#x9;&#x9;&#x9;curConnector.Update();&#xA;&#x9;&#x9;&#x9;newElement.Update();&#xA;&#x9;&#x9;&#x9;curElementSupplier.Update();&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnectorProperties( &quot; + curConnector.ConnectorGUID + &quot; ) updated curConnector.Name to &quot; + curConnector.Name + &quot;!!!&quot; );&#xA;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector so NOT updated!!!&quot; );&#xA;&#x9;&#x9;return &quot;updateConnector( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector so NOT updated!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Update theConnector with information as provided in the fields&#xA; */&#xA;function updateConnectorProperties( theConnector )&#xA;{&#xA;&#xA;&#x9;// Cast theConnector to EA.Connector so we get intellisense&#xA;&#x9;var curConnector as EA.Connector;&#xA;&#xA;&#x9;curConnector      = theConnector;&#xA;&#xA;&#x9;// Process theConnector&#xA;&#x9;if ( curConnector != null ) {&#xA;&#xA;&#x9;&#x9;// Process StandardConnectorFieldValues&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnectorProperties( &quot; + curConnector.ConnectorGUID + &quot; ) found curConnector.Name = &quot; + curConnector.Name + &quot;!!!&quot; );&#xA;&#x9;&#x9;IMEXISetStandardConnectorFieldValues( curConnector );&#xA;&#x9;&#x9;// Session.Output(&quot;updateConnectorProperties( &quot; + curConnector.ConnectorGUID + &quot; ) updated curConnector.Name to &quot; + curConnector.Name + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;// Commit the changes to the repository&#xA;&#x9;&#x9;objGlobalEAPackage.Update();&#xA;&#x9;&#x9;objGlobalEAPackage.Elements.Refresh();&#xA;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;return &quot;updateConnectorProperties() could NOT find curConnector so NOT updated!!!&quot; ;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Delete theConnector with information as provided&#xA; */&#xA;function deleteConnector()&#xA;{&#xA;&#xA;&#x9;// Find and process the element found by curConnectorGUID&#xA;&#x9;let curConnectorGUID = EXCELIGetColumnValueByName(&quot;CONNECTORGUID&quot;);&#xA;&#x9;// Session.Output(&quot;deleteConnector looking for curConnectorGUID: &quot; + curConnectorGUID + &quot;!!!&quot; );&#xA;&#x9;if ( curConnectorGUID == null ) {&#xA;&#x9;&#x9;// Session.Output(&quot;deleteConnector could NOT find curConnectorGUID: &quot; + curConnectorGUID + &quot; so NOT deleted!!!&quot; ;&#xA;&#x9;&#x9;return &quot;deleteConnector could NOT find curConnectorGUID: &quot; + curConnectorGUID + &quot; so NOT deleted!!!&quot; ;&#xA;&#x9;}&#xA;&#xA;&#x9;// Delete curConnectorGUID found&#xA;&#x9;// Session.Output(&quot;deleteConnector starting for curConnectorGUID = &quot; + curConnectorGUID + &quot;!!!&quot; );&#xA;&#x9;let curResult = CONDeleteConnectorByGUID( curConnectorGUID );&#xA;&#x9;// Session.Output(&quot;deleteConnector starting for curConnectorGUID = &quot; + curConnectorGUID + &quot; resulted in: &quot; + curResult + &quot;!!!&quot; );&#xA;&#x9;return curResult;&#xA;&#xA;}&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="18" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{382C074A-B177-4a0f-B070-AA6C70D3392C}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;ImExImportElementsJAVA&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatPackageScripts]&#xA;!INC Local Scripts.EAConstants-JavaScript&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;!INC EAScriptLib.JavaScript-Dialog&#xA;!INC EAScriptLib.JavaScript-XML&#xA;!INC BaatScriptLib.JavaScript-Connector&#xA;!INC BaatScriptLib.JavaScript-EXCEL&#xA;!INC BaatScriptLib.JavaScript-ImEx&#xA;&#xA;/*&#xA; * This code has been included from the default Project Browser template.&#xA; * If you wish to modify this template, it is located in the Config\Script Templates&#xA; * directory of your EA install path.   &#xA; * &#xA; * Script Name:&#x9;ImExImportElementsJAVA&#xA; * Author:&#x9;&#x9;J de Baat&#xA; * Purpose:&#x9;&#x9;Import the information from Elements into the selected Package&#xA; * Date:&#x9;&#x9;13-07-2024&#xA; * &#xA; */&#xA;&#xA;/*&#xA; * Handle the ExcelImport for importing Elements&#xA; */&#xA;function ImExImportElements( )&#xA;{&#xA;&#xA;&#x9;// Start the ExcelImport for this Import session&#xA;&#x9;// Session.Output(&quot;ImExImportElements started Excel.Application !&quot; );&#xA;&#x9;let strExcelImportResult = IMEXIHandleExcelImport( strDefaultElementsSheetName );&#xA;&#xA;&#x9;// Return the result found&#xA;&#x9;return strExcelImportResult;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process the Imported Elements found&#xA; */&#xA;function OnExcelRowImported( theRow )&#xA;{&#xA;&#xA;&#x9;let actionResult = &quot;&quot;;&#xA;&#x9;let importAction = &quot;&quot;;&#xA;&#x9;let importRow    = 0;&#xA;&#xA;&#x9;if ( excelImportCurrentRow[0] != null ) {&#xA;&#x9;&#x9;importAction = excelImportCurrentRow[0].toLowerCase();&#xA;&#x9;}&#xA;&#x9;importRow = theRow;&#xA;&#x9;// Session.Output(&quot;OnExcelRowImported excelImportCurrentRow(&quot; + importRow + &quot;).length = &quot; + excelImportCurrentRow.length + &quot;, Action = &quot; + excelImportCurrentRow[0] + &quot;!!!&quot; );&#xA;&#xA;&#x9;// Process importAction requested&#xA;&#x9;switch( importAction )&#xA;&#x9;{&#xA;&#x9;&#x9;case &quot;create&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = createElement();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;update&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = updateElement();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;delete&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = deleteElement();&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;&quot;:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9; actionResult = &quot;OnExcelRowImported found empty importAction!&quot;;&#xA;&#x9;&#x9;&#x9; break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Error message&#xA;&#x9;&#x9;&#x9;LOGError( &quot;OnExcelRowImported CANNOT process importAction &quot; + importAction + &quot;!&quot;  );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Create theElement with information as provided&#xA; */&#xA;function createElement()&#xA;{&#xA;&#xA;&#x9;var curElement as EA.Element;&#xA;&#xA;&#x9;// Find and process the element found by curElementGUID&#xA;&#x9;let curElementGUID = EXCELIGetColumnValueByName(&quot;CLASSGUID&quot;);&#xA;&#x9;curElement = GetElementByGuid( curElementGUID );&#xA;&#x9;if ( curElement != null ) {&#xA;&#x9;&#x9;return &quot;createElement( &quot; + curElementGUID + &quot; ) found curElement.Name = &quot; + curElement.Name + &quot; so skip creation to prevent duplicates!!!&quot;;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;// createElement could NOT find curElement so create new one&#xA;&#x9;&#x9;let curElementName = EXCELIGetColumnValueByName(&quot;Name&quot;);&#xA;&#x9;&#x9;let curElementType = EXCELIGetColumnValueByName(&quot;CLASSTYPE&quot;);&#xA;&#x9;&#x9;// Session.Output(&quot;createElement( &quot; + curElementGUID + &quot; ) could NOT find curElement so create new one with Name &quot; + curElementName + &quot;!!!&quot; );&#xA;&#x9;&#x9;curElement = objGlobalEAPackage.Elements.AddNew( curElementName, curElementType );&#xA;&#xA;&#x9;&#x9;// createElement created new curElement so update it using the other values found&#xA;&#x9;&#x9;if ( curElement != null ) {&#xA;&#xA;&#x9;&#x9;&#x9;// Process the updates for curElement found&#xA;&#x9;&#x9;&#x9;let curResult = updateElementProperties( curElement );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;createElement( &quot; + curElementGUID + &quot; ) updated curElement.Name to &quot; + curElement.Name + &quot;, curResult= &quot; + curResult + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;// Commit the changes to the repository&#xA;&#x9;&#x9;&#x9;objGlobalEAPackage.Update();&#xA;&#x9;&#x9;&#x9;objGlobalEAPackage.Elements.Refresh();&#xA;&#xA;&#x9;&#x9;} else {&#xA;&#xA;&#x9;&#x9;&#x9;return &quot;createElement( &quot; + curElementGUID + &quot; ) could NOT create curElement so NOT updated!!!&quot;;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Update theElement with information as provided&#xA; */&#xA;function updateElement()&#xA;{&#xA;&#xA;&#x9;var curElement as EA.Element;&#xA;&#xA;&#x9;// Find and process the element found by curElementGUID&#xA;&#x9;let curElementGUID = EXCELIGetColumnValueByName(&quot;CLASSGUID&quot;);&#xA;&#x9;curElement = GetElementByGuid( curElementGUID );&#xA;&#x9;if ( curElement != null ) {&#xA;&#xA;&#x9;&#x9;// Process the updates for curElement found&#xA;&#x9;&#x9;// Session.Output(&quot;updateElement( &quot; + curElementGUID + &quot; ) found curElement.Name = &quot; + curElement.Name + &quot;, Visibility = &quot; + curElement.Visibility + &quot;!!!&quot; );&#xA;&#x9;&#x9;let curResult = updateElementProperties( curElement );&#xA;&#x9;&#x9;// Session.Output(&quot;updateElement( &quot; + curElementGUID + &quot; ) updated curElement.Name to &quot; + curElement.Name + &quot;, curResult= &quot; + curResult + &quot;!!!&quot; );&#xA;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;return &quot;updateElement( &quot; + curElementGUID + &quot; ) could NOT find curElement so NOT updated!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Update theElement with information as provided in the fields&#xA; */&#xA;function updateElementProperties( theElement )&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var curElement     as EA.Element;&#xA;&#x9;var curElementTag  as EA.TaggedValue;&#xA;&#x9;var curElementTags as EA.Collection;&#xA;&#xA;&#x9;curElement            = theElement;&#xA;&#xA;&#x9;// Process theElement&#xA;&#x9;if ( curElement != null ) {&#xA;&#xA;&#x9;&#x9;curElementTags   = curElement.TaggedValues;&#xA;&#xA;&#x9;&#x9;// Procees StandardElementFieldValues&#xA;&#x9;&#x9;// Session.Output(&quot;updateElementProperties( &quot; + curElement.ElementGUID + &quot; ) found curElement.Name = &quot; + curElement.Name + &quot;, Visibility = &quot; + curElement.Visibility + &quot;!!!&quot; );&#xA;&#x9;&#x9;IMEXISetStandardElementFieldValues( curElement );&#xA;&#x9;&#x9;// Session.Output(&quot;updateElementProperties( &quot; + curElement.ElementGUID + &quot; ) updated curElement.Name to &quot; + curElement.Name + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;// Procees StandardElementTaggedValues&#xA;&#x9;&#x9;// Session.Output(&quot;updateElementProperties( &quot; + curElement.ElementGUID + &quot; ) found curElement.Name = &quot; + curElement.Name + &quot;, Visibility = &quot; + curElement.Visibility + &quot;!!!&quot; );&#xA;&#x9;&#x9;IMEXISetElementTaggedValues( curElement );&#xA;&#x9;&#x9;// Session.Output(&quot;updateElementProperties( &quot; + curElement.ElementGUID + &quot; ) updated curElement.Name to &quot; + curElement.Name + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;// Commit the changes to the repository&#xA;&#x9;&#x9;objGlobalEAPackage.Update();&#xA;&#x9;&#x9;objGlobalEAPackage.Elements.Refresh();&#xA;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;return &quot;updateElementProperties() could NOT find curElement so NOT updated!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;/*&#xA; * Delete theElement with information as provided&#xA; */&#xA;function deleteElement()&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var curElement as EA.Element;&#xA;&#xA;&#x9;// Find and process the element found by curElementGUID&#xA;&#x9;let curElementGUID = EXCELIGetColumnValueByName(&quot;CLASSGUID&quot;);&#xA;&#x9;curElement = GetElementByGuid( curElementGUID );&#xA;&#x9;if ( curElement != null ) {&#xA;&#x9;&#x9;// Session.Output(&quot;deleteElement( &quot; + curElementGUID + &quot; ) found curElement.Name = &quot; + curElement.Name + &quot;, ElementID = &quot; + curElement.ElementID + &quot;, ParentID = &quot; + curElement.ParentID + &quot;, PackageID = &quot; + curElement.PackageID + &quot;!!!&quot; );&#xA;&#x9;&#x9;// Delete the element as part of the curElement.ParentID&#xA;&#x9;&#x9;var curParentElement as EA.Element;&#xA;&#x9;&#x9;var curTempElement   as EA.Element;&#xA;&#x9;&#x9;curParentElement = Repository.GetElementByID( curElement.ParentID );&#xA;&#x9;&#x9;if ( curParentElement != null ) {&#xA;&#x9;&#x9;&#x9;// Find the index in the curParentElement.Elements for the curElement to delete&#xA;&#x9;&#x9;&#x9;for ( let i = 0 ; i &lt; curParentElement.Elements.Count ; i++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;curTempElement = curParentElement.Elements.GetAt( i );&#xA;&#x9;&#x9;&#x9;&#x9;if ( curTempElement.ElementID == curElement.ElementID ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curParentElement.Elements.DeleteAt( i, false );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output(&quot;deleteElement deleted curParentElement(&quot; + i + &quot;) where curElement.ElementID = &quot; + curElement.ElementID + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;break; // Stop processing the rest of the Elements in the for loop&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;curParentElement.Elements.Refresh();&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;// Delete the element as part of the curElement.PackageID&#xA;&#x9;&#x9;&#x9;var curParentPackage as EA.Package;&#xA;&#x9;&#x9;&#x9;curParentPackage = Repository.GetPackageByID( curElement.PackageID );&#xA;&#x9;&#x9;&#x9;if ( curParentPackage != null ) {&#xA;&#x9;&#x9;&#x9;&#x9;// Find the index in the curParentPackage.Elements for the curElement to delete&#xA;&#x9;&#x9;&#x9;&#x9;for ( let i = 0 ; i &lt; curParentPackage.Elements.Count ; i++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curTempElement = curParentPackage.Elements.GetAt( i );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ( curTempElement.ElementID == curElement.ElementID ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;curParentPackage.Elements.DeleteAt( i, false );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output(&quot;deleteElement deleted curParentPackage(&quot; + i + &quot;) where curElement.ElementID = &quot; + curElement.ElementID + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break; // Stop processing the rest of the Elements in the for loop&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;curParentPackage.Elements.Refresh();&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;return &quot;deleteElement( &quot; + curElementGUID + &quot; ) could NOT find curElement in ParentID nor PackageID!!!&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;return &quot;deleteElement( &quot; + curElementGUID + &quot; ) could NOT find curElement so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="19" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{23256E37-0060-48e0-A927-EEDC3C84B2EF}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;JavaScript-Connector&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatScriptLib]&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;&#xA;/**&#xA; * @file JavaScript-Connector &#xA; * This script library contains helper functions for working with Connectors. Functions &#xA; * provided by this module are identified by the prefix CON.&#xA; *&#xA; * @author J. de Baat, based on JavaScript-TaggedValue by Sparx Systems&#xA; * @date 2024-07-13&#xA; */&#xA;&#xA;/**&#xA; * Retrieves the Connector object from the provided element whose data matches the specified parameters.&#xA; * If the element does not exist, or does not contain a Connector with the specified data, null&#xA; * is returned.&#xA; * NOTE: A Connector is found if the ClientID AND SupplierID and Type are identical.&#xA; *&#xA; * @param[in] theElement (EA.Element) The element to retrieve the Connector value from&#xA; * @param[in] theClientID (String) The ID of the Element registered as Source of the Connector&#xA; * @param[in] theSupplierID (String) The ID of the Element registered as Target of the Connector&#xA; * @param[in] theType (String) The type of the Connector to be found, if empty string, any type will match&#xA; *&#xA; * @return The object of the requested Connector found, null when not found&#xA; */&#xA;function CONGetElementConnectorByData( theElement /* : EA.Element */, theClientID /* : ID */, theSupplierID /* : ID */, theType /* : String */ ) /* : EA.Connector */&#xA;{&#xA;&#xA;&#x9;// Validate input parameters&#xA;&#x9;if ( ( theElement != null ) &amp;&amp; ( theClientID &gt; 0 ) ) {&#xA;&#xA;&#x9;&#x9;// Cast the input values to objects so we get intellisense&#xA;&#x9;&#x9;var curElement           as EA.Element;&#xA;&#x9;&#x9;var curElementConnectors as EA.Collection;&#xA;&#x9;&#x9;var curConnector         as EA.Connector;&#xA;&#xA;&#x9;&#x9;curElement           = theElement;&#xA;&#x9;&#x9;curElementConnectors = curElement.Connectors;&#xA;&#xA;&#x9;&#x9;// Check all element Connectors against data to find&#xA;&#x9;&#x9;for ( var i = 0 ; i &lt; curElementConnectors.Count ; i++ )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;curConnector = curElementConnectors.GetAt( i );&#xA;&#x9;&#x9;&#x9;if ( ( curConnector.ClientID   == theClientID ) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9; ( curConnector.SupplierID == theSupplierID ) &amp;&amp;&#xA;&#x9;&#x9;&#x9;&#x9; ( ( &quot;&quot; === theType ) || ( curConnector.Type == theType ) ) ) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Connector found so clean up memory and return object&#xA;&#x9;&#x9;&#x9;&#x9;curElementConnectors = null;&#xA;&#x9;&#x9;&#x9;&#x9;return curConnector;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Clean up memory&#xA;&#x9;&#x9;curElementConnectors = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return null;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Sets the specified Connector on the provided element. If the provided element does not already&#xA; * contain a Connector with the specified data, a new Connector is created.&#xA; * If a Connector already exists with the specified data then the action is ignored.&#xA; * NOTE: A Connector is found if the ClientID AND SupplierID and Type are identical.&#xA; *&#xA; * @param[in] theElementClient (EA.Element) The element to add the Connector to and registered as Source of the Connector&#xA; * @param[in] theElementSupplier (EA.Element) The element to be registered as Target of the Connector&#xA; * @param[in] theType (String) The type of the Connector to be found, if empty string, any type will match&#xA; * @param[in] skipDuplicate (boolean) If set to true, check for existing connector to prevent duplicate&#xA; *&#xA; * @return The object of the Connector added or found, null in case of error&#xA; */&#xA;function CONSetElementConnector( theElementClient /* : EA.Element */, theElementSupplier /* : EA.Element */, theType /* : String */, skipDuplicate /* : Boolean */ ) /* : EA.Connector */&#xA;{&#xA;&#xA;&#x9;// Validate input parameters&#xA;&#x9;if ( ( theElementClient != null ) &amp;&amp; ( theElementSupplier != null ) &amp;&amp; ( theType != &quot;&quot; ) ) {&#xA;&#xA;&#x9;&#x9;// Cast the input values to objects so we get intellisense&#xA;&#x9;&#x9;var curElementClient     as EA.Element;&#xA;&#x9;&#x9;var curElementSupplier   as EA.Element;&#xA;&#x9;&#x9;var curElementConnectors as EA.Collection;&#xA;&#x9;&#x9;var curConnector         as EA.Connector;&#xA;&#xA;&#x9;&#x9;curElementClient         = theElementClient;&#xA;&#x9;&#x9;curElementSupplier       = theElementSupplier;&#xA;&#x9;&#x9;curConnector             = null;&#xA;&#xA;&#x9;&#x9;const theConnectorDirection = &quot;Unspecified&quot;;&#xA;&#xA;&#x9;&#x9;// Check all Connectors in curElementClient whether the requested Connector already exists&#xA;&#x9;&#x9;if ( skipDuplicate ) {&#xA;&#x9;&#x9;&#x9;curConnector         = CONGetElementConnectorByData( curElementClient, curElementClient.ElementID, curElementSupplier.ElementID, theType );&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// If curConnector is not found, create a new Connector between curElementClient and curElementSupplier&#xA;&#x9;&#x9;if ( curConnector == null )&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;curElementConnectors = curElementClient.Connectors;&#xA;&#x9;&#x9;&#x9;curConnector         = curElementConnectors.AddNew( curElementClient.Name, theType );&#xA;&#xA;&#x9;&#x9;&#x9;// If curConnector is added, set the attributes&#xA;&#x9;&#x9;&#x9;if ( curConnector != null )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.Name       = &quot;&quot;;     // Reset the dummy name as needed for AddNew&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientID   = curElementClient.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierID = curElementSupplier.ElementID;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.Direction  = theConnectorDirection;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.Type       = theType;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Commit changes to the Repository&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curElementConnectors.Refresh();&#xA;&#x9;&#x9;&#x9;&#x9;curElementClient.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curElementSupplier.Update();&#xA;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError(&quot;CONSetElementConnector could NOT create new Connector between Client(&quot; + curElementClient.ElementID + &quot;) and Supplier(&quot; + curElementSupplier.ElementID + &quot;) for Type &quot; + theType + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError(&quot;CONSetElementConnector skipped create duplicate Connector between Client(&quot; + curElementClient.ElementID + &quot;) and Supplier(&quot; + curElementSupplier.ElementID + &quot;) for Type &quot; + theType + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Return the curConnector found or added&#xA;&#x9;&#x9;return curConnector;&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Deletes the specified Connector on the provided element.&#xA; * NOTE: A Connector is found if the ClientID AND SupplierID and Type are identical.&#xA; *&#xA; * @param[in] theConnectorGUID (String) The GUID of the Connector to be deleted&#xA; */&#xA;function CONDeleteConnectorByGUID( theConnectorGUID /* : String */ ) /* : void */&#xA;{&#xA;&#xA;&#x9;// Cast theConnector to EA.Connector so we get intellisense&#xA;&#x9;var curConnector       as EA.Connector;&#xA;&#x9;var curElementClient   as EA.Element;&#xA;&#x9;var curElementSupplier as EA.Element;&#xA;&#xA;&#x9;// Find the curConnectorGUID to identify the Connector&#xA;&#x9;let curConnectorGUID = theConnectorGUID;&#xA;&#x9;if ( curConnectorGUID == null ) {&#xA;&#x9;&#x9;// Session.Output( &quot;CONDeleteConnectorByGUID could NOT find curConnectorGUID so NOT deleted!!!&quot;);&#xA;&#x9;&#x9;return &quot;CONDeleteConnectorByGUID could NOT find curConnectorGUID so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Find the curConnectorGUID&#xA;&#x9;curConnector = GetConnectorByGuid( curConnectorGUID );&#xA;&#x9;if ( curConnector == null ) {&#xA;&#x9;&#x9;// Session.Output( &quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector so NOT deleted!!!&quot;);&#xA;&#x9;&#x9;return &quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;// Find and process the source element defined by Start_Object_ID&#xA;&#x9;let curElementClientID = curConnector.ClientID;&#xA;&#x9;curElementClient       = GetElementByID( curElementClientID );&#xA;&#x9;if ( curElementClient == null ) {&#xA;&#x9;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so NOT deleted!!!&quot; );&#xA;&#x9;&#x9;return &quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curElementClient with curElementClientID = &quot; + curElementClientID + &quot; so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Find and process the target element defined by End_Object_ID&#xA;&#x9;let curElementSupplierID = curConnector.SupplierID;&#xA;&#x9;curElementSupplier       = GetElementByID( curElementSupplierID );&#xA;&#x9;if ( curElementSupplier == null ) {&#xA;&#x9;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so NOT deleted!!!&quot; );&#xA;&#x9;&#x9;return &quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Process the Connector found by curConnectorGUID between curElementClient and curElementSupplier&#xA;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) found curConnector.ConnectorID = &quot; + curConnector.ConnectorID + &quot;, ClientID = &quot; + curConnector.ClientID + &quot;, SupplierID = &quot; + curConnector.SupplierID + &quot;!!!&quot; );&#xA;&#x9;// Delete the element as part of the curConnector.ClientID&#xA;&#x9;var curTempConnector   as EA.Connector;&#xA;&#x9;let curConnectorDeleted = false;&#xA;&#x9;// Find the index in the curElementClient.Connectors for the curConnector to delete&#xA;&#x9;for ( let i = 0 ; i &lt; curElementClient.Connectors.Count ; i++ ) {&#xA;&#x9;&#x9;curTempConnector = curElementClient.Connectors.GetAt( i );&#xA;&#x9;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID TESTING curElementClient(&quot; + i + &quot;) where curTempConnector.ConnectorID = &quot; + curTempConnector.ConnectorID + &quot;!!!&quot; );&#xA;&#x9;&#x9;if ( curTempConnector.ConnectorID == curConnector.ConnectorID ) {&#xA;&#x9;&#x9;&#x9;curElementClient.Connectors.DeleteAt( i, false );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID deleted curElementClient(&quot; + i + &quot;) where curConnector.ConnectorID = &quot; + curConnector.ConnectorID + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;curConnectorDeleted = true;&#xA;&#x9;&#x9;&#x9;break; // Stop processing the rest of the Connectors in the for loop&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// Check curConnectorDeleted to commit updates to refresh changes&#xA;&#x9;if ( curConnectorDeleted ) {&#xA;&#x9;&#x9;curElementClient.Connectors.Refresh();&#xA;&#x9;&#x9;curElementSupplier.Connectors.Refresh();&#xA;&#x9;} else {&#xA;&#x9;&#x9;// Session.Output(&quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curElementSupplier with curElementSupplierID = &quot; + curElementSupplierID + &quot; so NOT deleted!!!&quot; );&#xA;&#x9;&#x9;return &quot;CONDeleteConnectorByGUID( &quot; + curConnectorGUID + &quot; ) could NOT find curConnector.ConnectorID = &quot; + curConnector.ConnectorID + &quot; within &quot; + curElementClient.Connectors.Count + &quot; curElementClient.Connectors so NOT deleted!!!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="20" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{5816F0F4-C7D9-4b82-B66B-9028223849D7}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;JavaScript-EXCEL&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatScriptLib]&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;&#xA;/**&#xA; * @file JavaScript-EXCEL&#xA; * This script library contains helper functions to assist with EXCEL Import and Export of&#xA; * Enterprise Architect elements. &#xA; * &#xA; * Functions in this library are split into three parts: Workbooks, Import and Export.&#xA; * Functions that assist with EXCEL Workbooks are prefixed with EXCELW,&#xA; * EXCEL Import are prefixed with EXCELI, whereas functions that assist with EXCEL Export are prefixed &#xA; * with EXCELE.&#xA; *&#xA; * EXCEL Import can be performed by calling the function EXCELIImportFile(). EXCELIImportFile() requires&#xA; * that the function OnExcelRowImported() be defined in the user's script to be used as a callback&#xA; * whenever row data is read from the EXCEL file. The user defined OnExcelRowImported() can query for &#xA; * information about the current row through the functions EXCELIContainsColumn(), &#xA; * EXCELIGetColumnValueByName() and EXCELIGetColumnValueByNumber().&#xA; *&#xA; * To perform an EXCEL export, the user must firstly call EXCELEExportInitialize() which starts an export &#xA; * session. The call to EXCELEExportInitialize() specifies the file name to export to, and the set of &#xA; * columns that will be exported. Once the session has been initialized with a call to &#xA; * EXCELEExportInitialize(), the user may continually call EXCELEExportRow() to export a row to file. &#xA; * Once all rows have been added, the export session is closed by calling EXCELEExportFinalize(). &#xA; *&#xA; * @author J. de Baat, based on JavaScript - CSV by Sparx Systems&#xA; * @date 2024-07-13&#xA; */&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEL WORKBOOKS&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;var objExcelApplication = null;   // The global variable holding the Excel application running&#xA;var objExcelWorkBook    = null;   // The global variable holding the Excel WorkBook  in the file&#xA;var objExcelWorkSheet   = null;   // The global variable holding the Excel WorkSheet in the WorkBook&#xA;&#xA;const EXCEL_DELIMITER   = &quot;,&quot;;&#xA;const TAG_PREFIX        = &quot;TAG_&quot;;&#xA;&#xA;/**&#xA; * Returns the opened EXCEL Workbook from the fileName provided.&#xA; *&#xA; * @param[in] fileName (string) The path to the EXCEL file to open.&#xA;*/&#xA;function EXCELWOpenWorkbook( fileName /* : String */ ) /* : Microsoft.Office.Interop.Excel._Workbook */&#xA;{&#xA;&#xA;&#x9;objExcelWorkBook = null;&#xA;&#xA;&#x9;// Get objExcelWorkBook from the fileName provided&#xA;&#x9;try {&#xA;&#x9;&#x9;objExcelWorkBook = objExcelApplication.Workbooks.Open( fileName );&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWOpenWorkbook catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;objExcelWorkBook = null;&#xA;&#x9;}&#xA;&#x9;if ( objExcelWorkBook != null ) {&#xA;&#x9;&#x9;// objExcelWorkBook FOUND&#xA;&#x9;&#x9;Session.Output(&quot;EXCELWOpenWorkbook Found Workbook with fileName = &quot; + fileName + &quot; !&quot; );&#xA;&#x9;} else {&#xA;&#x9;&#x9;// Make sure we have a file&#xA;&#x9;&#x9;// Session.Output( &quot;EXCELWGetFileName Started with strExcelFileName = &quot; + strExcelFileName + &quot; !&quot; );&#xA;&#x9;&#x9;strExcelFileName = EXCELWCheckExcelFileName( strExcelFileName );&#xA;&#x9;&#x9;Session.Output( &quot;EXCELWGetFileName Checked strExcelFileName = &quot; + strExcelFileName + &quot; !&quot; );&#xA;&#xA;&#x9;&#x9;// If the file does not exist, then create one&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;objExcelWorkBook = objExcelApplication.Workbooks.Add();&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWOpenWorkbook objExcelApplication contains &quot; + objExcelApplication.Workbooks.Count + &quot; Workbooks after Add!&quot; );&#xA;&#x9;&#x9;&#x9;Session.Output(&quot;EXCELWOpenWorkbook created a new Workbook with fileName = &quot; + fileName + &quot; !&quot; );&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWOpenWorkbook could NOT open nor add fileName &quot; + fileName + &quot;, catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;objExcelWorkBook = null;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return objExcelWorkBook;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Check theExcelFileName and create new file when the file does not exist&#xA; */&#xA;function EXCELWCheckExcelFileName( theExcelFileName ) /* : string */&#xA;{&#xA;&#xA;&#x9;let strExcelFileName = &quot;&quot;;&#xA;&#x9;strExcelFileName     = theExcelFileName;&#xA;&#xA;&#x9;// Make sure we have a filename&#xA;&#x9;if ( ( strExcelFileName == null ) || ( strExcelFileName.length == 0 ) ) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName could NOT check empty strExcelFileName!&quot; );&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;// Session.Output( &quot;EXCELWCheckExcelFileName checking strExcelFileName = &quot; + strExcelFileName + &quot;!!!&quot; );&#xA;&#xA;&#x9;// Create a fileSystemObject to check the existence of the file chosen&#xA;&#x9;try {&#xA;&#x9;&#x9;var fileSystemObject = new COMObject( &quot;Scripting.FileSystemObject&quot; );&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#x9;if ( fileSystemObject.FileExists( strExcelFileName ) ) {&#xA;&#xA;&#x9;&#x9;// File exists so return the name found&#xA;&#x9;&#x9;// Session.Output( &quot;EXCELWCheckExcelFileName found strExcelFileName = &quot; + strExcelFileName + &quot; in filesystem!!!&quot; );&#xA;&#x9;&#x9;fileSystemObject = null;&#xA;&#x9;&#x9;return strExcelFileName;&#xA;&#x9;} else {&#xA;&#xA;&#x9;&#x9;// If the file does not exist, then create one&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;objExcelWorkBook = objExcelApplication.Workbooks.Add();&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;objExcelWorkBook = null;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// Session.Output(&quot;EXCELWCheckExcelFileName objExcelApplication DefaultFilePath = &quot; + objExcelApplication.DefaultFilePath + &quot;!!!&quot; );&#xA;&#x9;&#x9;// Session.Output(&quot;EXCELWCheckExcelFileName objExcelApplication contains &quot; + objExcelApplication.Workbooks.Count + &quot; Workbooks after Add!&quot; );&#xA;&#x9;&#x9;if ( objExcelWorkBook != null ) {&#xA;&#x9;&#x9;&#x9;let strExcelWorkBookFullName = &quot;&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;// If the file added, then save it&#xA;&#x9;&#x9;&#x9;objExcelWorkBook.Save( true );&#xA;&#x9;&#x9;&#x9;strExcelWorkBookFullName = objExcelWorkBook.FullName;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWCheckExcelFileName saved objExcelWorkBook with FullName = &quot; + objExcelWorkBook.FullName + &quot; after Add!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;// Close the newly added objExcelWorkBook to move the file&#xA;&#x9;&#x9;&#x9;objExcelWorkBook.Close();&#xA;&#x9;&#x9;&#x9;objExcelWorkBook = null;&#xA;&#xA;&#x9;&#x9;&#x9;// Check filesystem whether file exists&#xA;&#x9;&#x9;&#x9;let objExcelFile = null;&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;objExcelFile = fileSystemObject.GetFile( strExcelWorkBookFullName );&#xA;&#x9;&#x9;&#x9;&#x9;objExcelFile.Move( strExcelFileName );&#xA;&#x9;&#x9;&#x9;&#x9;objExcelFile = null;&#xA;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName could NOT open objExcelFile for strExcelFileName &quot; + strExcelWorkBookFullName + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;fileSystemObject = null;&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWCheckExcelFileName created a new Workbook with strExcelFileName = &quot; + strExcelFileName + &quot; !&quot; );&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWCheckExcelFileName could NOT open nor add strExcelFileName &quot; + strExcelFileName + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;fileSystemObject = null;&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;fileSystemObject = null;&#xA;&#x9;return strExcelFileName;&#xA;}&#xA;&#xA;/**&#xA; * Saves the provided EXCEL Workbook with the fileName provided.&#xA; *&#xA; * @param[in] fileName (string) The path to the EXCEL file to save to.&#xA;*/&#xA;function EXCELWSaveWorkbook( fileName /* : String */ ) /* : void */&#xA;{&#xA;&#x9;if ( objExcelWorkBook != null ) {&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;// objExcelWorkBook FOUND&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook saves Workbook with fileName = &quot; + fileName + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;objExcelWorkBook.SaveAs( fileName );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook objExcelWorkBook FullName = &quot; + objExcelWorkBook.FullName + &quot; after SaveAs!&quot; );&#xA;&#x9;&#x9;&#x9;objExcelWorkBook.Save(  true  );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook objExcelWorkBook FullName = &quot; + objExcelWorkBook.FullName + &quot; after Save!&quot; );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook objExcelApplication contains &quot; + objExcelApplication.Workbooks.Count + &quot; Workbooks!&quot; );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook objExcelWorkBook contains &quot; + objExcelWorkBook.Sheets.Count + &quot; Sheets!&quot; );&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWSaveWorkbook saved Workbook with fileName = &quot; + fileName + &quot; !&quot; );&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWSaveWorkbook catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWSaveWorkbook could NOT save Workbook to fileName &quot; + fileName + &quot;!&quot; );&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Closes the provided EXCEL Workbooks opened before.&#xA; *&#xA; * @param[in] saveWorkbook (boolean) If set to true, the Workbook is saved without asking for confirmation&#xA;*/&#xA;function EXCELWCloseWorkbooks( saveWorkbook /* : boolean */ ) /* : void */&#xA;{&#xA;&#x9;try {&#xA;&#x9;&#x9;if ( ( saveWorkbook != null ) &amp;&amp; ( saveWorkbook ) ) {&#xA;&#x9;&#x9;&#x9;objExcelWorkBook.Save( true );&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;objExcelApplication.Workbooks.Close();&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWCloseWorkbooks catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Start the EXCEL Application.&#xA; *&#xA;*/&#xA;function EXCELWStartExcelApplication() /* : void */&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#x9;&#x9;objExcelApplication = new COMObject( &quot;Excel.Application&quot;, true );&#xA;&#x9;&#x9;if ( objExcelApplication != null ) {&#xA;&#x9;&#x9;&#x9;// objExcelApplication STARTED&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWStartExcelApplication started Excel.Application !&quot; );&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWStartExcelApplication could NOT start Excel.Application!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWStartExcelApplication catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;objExcelApplication = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return objExcelApplication;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Stop the provided EXCEL Application started before.&#xA; *&#xA;*/&#xA;function EXCELWStopExcelApplication() /* : void */&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#x9;&#x9;objExcelApplication.Quit();&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWStopExcelApplication catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;objExcelApplication = null;&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Gets the Worksheet as part of the provided EXCEL Workbooks using the sheetName provided.&#xA; * If the Worksheet does not exist and addSheet is true, it is added to the Workbooks Collection&#xA; *&#xA; * @param[in] sheetName (string) The name of the Worksheet in the EXCEL file to get or create.&#xA; * @param[in] addSheet (boolean) If set to true, the Worksheet is added if it does not exist&#xA;*/&#xA;function EXCELWGetWorksheet( sheetName /* : String */, addSheet /* : boolean */ ) /* : void */&#xA;{&#xA;&#xA;&#x9;var curExcelWorkSheet = null;&#xA;&#xA;&#x9;// Check valid objExcelWorkBook&#xA;&#x9;if ( objExcelWorkBook == null ) {&#xA;&#x9;&#x9;// objExcelWorkBook NOT FOUND&#xA;&#x9;&#x9;LOGError( &quot;EXCELWGetWorksheet Could NOT get Worksheet &quot; + sheetName + &quot; because objExcelWorkBook NOT opened!&quot; );&#xA;&#x9;&#x9;return curExcelWorkSheet;&#xA;&#x9;}&#xA;&#xA;&#x9;// Get the curExcelWorkSheet&#xA;&#x9;try {&#xA;&#x9;&#x9;curExcelWorkSheet = objExcelWorkBook.Sheets.Item( sheetName );&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWGetWorksheet catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;curExcelWorkSheet = null;&#xA;&#x9;}&#xA;&#x9;if ( curExcelWorkSheet == null ) {&#xA;&#x9;&#x9;// Create the curExcelWorkSheet if it is not found and addSheet is true&#xA;&#x9;&#x9;if ( addSheet ) {&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;curExcelWorkSheet = objExcelWorkBook.Sheets.Add();&#xA;&#x9;&#x9;&#x9;&#x9;curExcelWorkSheet.Name = sheetName;&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output(&quot;EXCELWGetWorksheet created Worksheet with sheetName = &quot; + curExcelWorkSheet.Name + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWGetWorksheet Could NOT get Worksheet with sheetName = &quot; + sheetName + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELWGetWorksheet catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;curExcelWorkSheet = null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return curExcelWorkSheet;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Get the strExcelFileName to process&#xA; *&#xA; * @param[in] fileName (string) The path to the EXCEL file to open as specified by default&#xA; * @param[in] readOnly (boolean) If set to true, the file is opened for read otherwise for write&#xA; */&#xA;function EXCELWGetFileName( fileName /* : String */, readOnly /* : boolean */ ) /* : string */&#xA;{&#xA;&#x9;// Define some variables and values&#xA;&#x9;var projectInterface as EA.Project&#xA;&#x9;var strExcelFileName, FilterString, Filterindex, Flags, InitialDirectory, OpenorSave;&#xA;&#x9;strExcelFileName = fileName;&#xA;&#x9;FilterString     = &quot;Excel Files (*.xlsx;*.xlsm;*.xls)|*.xlsx;*.xlsm;*.xls|All Files (*.*)|*.*||&quot;;&#xA;&#x9;Filterindex      = 1;&#xA;&#x9;Flags            = 0;&#xA;&#x9;InitialDirectory = &quot;&quot;;&#xA;&#x9;if ( readOnly ) {&#xA;&#x9;&#x9;OpenorSave   = 0;&#xA;&#x9;} else {&#xA;&#x9;&#x9;OpenorSave   = 1;&#xA;&#x9;}&#xA;&#xA;&#x9;// Get the strExcelFileName to get the information from&#xA;&#x9;try {&#xA;&#x9;&#x9;projectInterface = Repository.GetProjectInterface();&#xA;&#x9;&#x9;strExcelFileName = projectInterface.GetFileNameDialog( strExcelFileName, FilterString, Filterindex, Flags, InitialDirectory, OpenorSave );&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWGetFileName catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;strExcelFileName = &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Make sure we have a filename&#xA;&#x9;if ( strExcelFileName.length == 0 ) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELWGetFileName Could NOT get a valid fileName, starting with : &quot; + fileName + &quot; !&quot; );&#xA;&#x9;&#x9;return null;&#xA;&#x9;} else {&#xA;&#x9;&#x9;// Make sure we have a file&#xA;&#x9;&#x9;// Session.Output( &quot;EXCELWGetFileName Found strExcelFileName = &quot; + strExcelFileName + &quot; !&quot; );&#xA;&#x9;&#x9;strExcelFileName = EXCELWCheckExcelFileName( strExcelFileName );&#xA;&#x9;&#x9;Session.Output( &quot;EXCELWGetFileName Checked strExcelFileName = &quot; + strExcelFileName + &quot; !&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;return strExcelFileName;&#xA;}&#xA;&#xA;/**&#xA; * If theValue starts with thePrefix then return value without prefix else return empty string&#xA; *&#xA; * @param[in] theValue (string) The value to test.&#xA; * @param[in] thePrefix (string) The prefix to test against.&#xA; */&#xA;function EXCELGGetValueWithoutPrefix( theValue, thePrefix )&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#x9;&#x9;const thePrefixLength = thePrefix.length;&#xA;&#x9;&#x9;// Session.Output(&quot;EXCELGGetValueWithoutPrefix started with thePrefix : &quot; + thePrefix + &quot;, length = &quot; + thePrefixLength + &quot; !&quot; );&#xA;&#xA;&#x9;&#x9;//&#x9;If theValue starts with thePrefix then return value without prefix&#xA;&#x9;&#x9;if ( theValue.substring( 0, thePrefixLength ).toLowerCase() == thePrefix.toLowerCase() ) {&#xA;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELGGetValueWithoutPrefix found theValue.substring(&quot; + thePrefixLength + &quot;)= &quot; + theValue.substring( thePrefixLength ) + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;return theValue.substring( thePrefixLength );&#xA;&#x9;&#x9;}&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELGGetValueWithoutPrefix catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;&#xA;}&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEL IMPORT&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;var excelImportColumnMap;&#x9;&#x9;&#x9;&#x9;// : Map with column index values related to column headers&#xA;var excelImportColumnTagsMap;&#x9;&#x9;&#x9;// : Map with tag names found within the column headers&#xA;var excelImportColumnList;&#x9;&#x9;&#x9;&#x9;// : Array with column headers&#xA;var excelImportCurrentRow;&#x9;&#x9;&#x9;&#x9;// : Array with values found in this row&#xA;var excelImportIsImporting = false;&#xA;&#xA;/**&#xA; * Imports the provided EXCEL Workbooks as indicated by the sheetName.&#xA; * The user function OnExcelRowImported() is called to notify the user&#xA; * script that row data is available. The user script may then call EXCELIContainsColumn() to see&#xA; * if the current row contains a particular named column, and EXCELIGetColumnValueByName() or&#xA; * EXCELIGetColumnValueByNumber() to obtain the field value of a particular column.&#xA; *&#xA; * @param[in] sheetName (string) The name of the Worksheet in the EXCEL file to import.&#xA; * &#xA; * @param[in] firstRowContainsHeadings (boolean) If set to true, the values of the first row will be parsed&#xA; * as column headings. EXCELIContainsColumn() and EXCELIGetColumnValueByName() will only work if &#xA; * firstRowContainsHeadings is set to true.&#xA; */&#xA;function EXCELIImportSheet( sheetName /* : String */, firstRowContainsHeadings /* : boolean */ ) /* : void */&#xA;{&#xA;&#x9;if ( !excelImportIsImporting ) {&#xA;&#xA;&#x9;&#x9;// Check valid objExcelWorkBook&#xA;&#x9;&#x9;if ( objExcelWorkBook == null ) {&#xA;&#x9;&#x9;&#x9;// objExcelWorkBook NOT FOUND&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELIImportSheet Could NOT get Worksheet &quot; + sheetName + &quot; because objExcelWorkBook NOT opened!&quot; );&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;excelImportIsImporting = true;&#xA;&#xA;&#x9;&#x9;// Get and check the curExcelWorkSheet for sheetName&#xA;&#x9;&#x9;var curExcelWorkSheet  = EXCELWGetWorksheet( sheetName, false );&#xA;&#x9;&#x9;if ( curExcelWorkSheet != null ) {&#xA;&#xA;&#x9;&#x9;&#x9;// Set up row/column caching&#xA;&#x9;&#x9;&#x9;let curValue    = new String( &quot;&quot; );&#xA;&#x9;&#x9;&#x9;let RowCount    = 0;&#xA;&#x9;&#x9;&#x9;let ColumnCount = 0;&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;RowCount    = curExcelWorkSheet.UsedRange.Rows.Count;&#xA;&#x9;&#x9;&#x9;&#x9;ColumnCount = curExcelWorkSheet.UsedRange.Columns.Count;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;excelImportColumnMap     = new Map();&#xA;&#x9;&#x9;&#x9;&#x9;excelImportColumnTagsMap = new Map();&#xA;&#x9;&#x9;&#x9;&#x9;excelImportColumnList    = [];&#xA;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELIImportSheet catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;RowCount    = 0;&#xA;&#x9;&#x9;&#x9;&#x9;ColumnCount = 0;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Process the Worksheet a row at a time&#xA;&#x9;&#x9;&#x9;for ( var curRow = 1 ; curRow &lt;= RowCount ; curRow++ ) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;try {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Reset excelImportCurrentRow for next row&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;excelImportCurrentRow    = [];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ( curRow == 1 &amp;&amp; firstRowContainsHeadings )&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Cache column heading positions&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for ( var curCol = 1 ; curCol &lt;= ColumnCount ; curCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;curValue.text = curExcelWorkSheet.Cells.Item( curRow, curCol ).Value;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;excelImportColumnMap.set( curValue.text, curCol - 1 ); // Col starts with 1, List starts with 0&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;excelImportColumnList.push( curValue.text );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELIImportSheet excelImportColumnMap.set(&quot; + curValue.text + &quot;,&quot; + curCol + &quot;)!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELIImportSheet excelImportColumnList.push(&quot; + curValue.text + &quot;)!!!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ( curValue.text != null ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;let importColumnTag = EXCELGGetValueWithoutPrefix( curValue.text, TAG_PREFIX );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ( importColumnTag.length &gt; 0 ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;excelImportColumnTagsMap.set( curValue.text, importColumnTag );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELIImportSheet excelImportColumnTagsMap.set(&quot; + curValue.text + &quot;,&quot; + importColumnTag + &quot;)!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Hold a reference to the current row data&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Cache column heading positions&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for ( var curCol = 1 ; curCol &lt;= ColumnCount ; curCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;excelImportCurrentRow.push( curExcelWorkSheet.Cells.Item( curRow, curCol ).Value );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELIImportSheet excelImportCurrentRow.push(&quot; + (curCol - 1) + &quot;) Cell(&quot; + curRow + &quot;,&quot; + curCol + &quot;): &quot; + curExcelWorkSheet.Cells.Item( curRow, curCol ).Value + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Invoke the user script callback&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;OnExcelRowImported( curRow );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELIImportSheet for row[&quot; + curRow + &quot;] catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELIImportSheet did NOT find sheetName &quot; + sheetName + &quot;!&quot;  );&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;// Clean up&#xA;&#x9;&#x9;excelImportColumnMap      = null;&#xA;&#x9;&#x9;excelImportColumnTagsMap  = null;&#xA;&#x9;&#x9;excelImportColumnList     = null;&#xA;&#x9;&#x9;excelImportCurrentRow     = null;&#xA;&#x9;&#x9;excelImportIsImporting    = false;&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;Reentrant call made to EXCELIImportSheet(). EXCELIImportSheet() should not be called from within OnExcelRowImported()!&quot; );&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Advises whether the current import row contains a field value for the specified column name.&#xA; *&#xA; * NOTE: The function only works if EXCELImportFile() was called with the firstRowContainsHeadings&#xA; * paremeter set to true.&#xA; *&#xA; * @param[in] (String) The name of the column to check for&#xA; *&#xA; * @return A boolean indicating whether the current import row contains a field value for the &#xA; * specified column name.&#xA; */&#xA;function EXCELIContainsColumn( columnName /* : String */ ) /* : boolean */&#xA;{&#xA;&#x9;var result = false;&#xA;&#x9;&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;// Get the column number of the specified named column&#xA;&#x9;&#x9;var columnNumber = __EXCELIGetColumnNumber( columnName );&#xA;&#x9;&#xA;&#x9;&#x9;// If the column is in range then it exists!&#xA;&#x9;&#x9;if ( columnNumber &gt;= 0 &amp;&amp; excelImportCurrentRow != null &amp;&amp; columnNumber &lt; excelImportCurrentRow.length ) {&#xA;&#x9;&#x9;&#x9;result = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. EXCELIContainsColumn() should only be called from within OnExcelRowImported()&quot; );&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * Returns the value of the field in the current import row with the specified column name&#xA; *&#xA; * NOTE: The function only works if EXCELImportFile() was called with the firstRowContainsHeadings&#xA; * paremeter set to true.&#xA; *&#xA; * @param[in] columnName (String) The name of the column whose value will be retrieved.&#xA; *&#xA; * @return The current import row's field value for the specified column&#xA; */&#xA;function EXCELIGetColumnValueByName( columnName /* : String */ ) /* : variant */&#xA;{&#x9;&#xA;&#x9;var result;&#xA;&#x9;&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;var columnNumber = __EXCELIGetColumnNumber( columnName );&#xA;&#x9;&#x9;result = EXCELIGetColumnValueByNumber( columnNumber );&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. EXCELIGetColumnValueByName() should only be called from within OnExcelRowImported()&quot; );&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * Returns the value of the field in the current import row with the specified column number&#xA; *&#xA; * @param[in] columnNumber (number) The index of the column whose value will be retrieved.&#xA; *&#xA; * @return The current import row's field value for the specified column&#xA; */&#xA;function EXCELIGetColumnValueByNumber( columnNumber /* : number */ ) /* : variant */&#xA;{&#xA;&#x9;var result;&#xA;&#x9;&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;if ( columnNumber &gt;= 0 &amp;&amp; excelImportCurrentRow != null &amp;&amp; columnNumber &lt; excelImportCurrentRow.length ) {&#xA;&#x9;&#x9;&#x9;result = excelImportCurrentRow[columnNumber];&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. EXCELIGetColumnValueByNumber() should only be called from within OnExcelRowImported()&quot; );&#xA;&#x9;}&#xA;&#x9;&#x9;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * Returns all column names that are not considered standard as an array of Strings.&#xA; */&#xA;function EXCELIGetNonStandardElementColumns() /* : Array */&#xA;{&#xA;&#x9;var result = [];&#x9;&#xA;&#x9;var standardColumns = new String(&quot;;Abstract;Alias;Author;ClassifierName;Complexity;Created&quot;);&#xA;&#x9;standardColumns += &quot;;Difficulty;GenFile;GenType;Header1;Header2;IsActive;IsLeaf&quot;;&#xA;&#x9;standardColumns += &quot;;IsNew;IsSpec;Locked;Multiplicity;Name;Notes;Persistence;Phase;Priority&quot;;&#xA;&#x9;standardColumns += &quot;;RunState;Status;Stereotype;Subtype;Tablespace;Tag;TreePos;Type;Version&quot;;&#xA;&#x9;standardColumns += &quot;;Visibility;&quot;;&#xA;&#x9;&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;for ( var i = 0 ; i &lt; excelImportCurrentRow.length ; i++ )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if ( i &lt; excelImportColumnList.length )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;var columnName = excelImportColumnList[i];&#xA;&#x9;&#x9;&#x9;&#x9;if ( standardColumns.indexOf( &quot;;&quot; + columnName + &quot;;&quot; ) == -1 )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result.push( columnName );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. EXCELIGetNonStandardElementColumns() should only be called from within OnExcelRowImported()&quot; );&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;/**&#xA; * Sets the properties on the specified Element if there is a corresponding value for them in the &#xA; * current row.&#xA; *&#xA; * Element properties that are not set by this function include:&#xA; * &#x9;- Read only properties&#xA; * &#x9;- Collection properties&#xA; * &#x9;- Properties that contain relational information (eg IDs/GUIDs of other elements, connectors &#xA; *&#x9;or packages.&#xA; *&#x9;- Modified Date property (this is property is automatically overwritten by the automation &#xA; *&#x9;interface when the element is saved)&#xA; *&#x9;- Properties that are themselves a comma separated list&#xA; *&#xA; * @param[in] elementForRow (EA.Element) The element whose properties will be set with the current row's &#xA; * values&#xA; */&#xA;function EXCELISetStandardElementFieldValues( elementForRow /* : EA.Element */ ) /* : void */&#xA;{&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;var theElement as EA.Element;&#xA;&#x9;&#x9;theElement = elementForRow;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;if ( theElement != null )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Abstract&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Abstract = EXCELIGetColumnValueByName(&quot;Abstract&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// ActionFlags - Not included (Comma Separated)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Alias&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Alias = EXCELIGetColumnValueByName(&quot;Alias&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Attributes - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// AttributesEx - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Author&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Author = EXCELIGetColumnValueByName(&quot;Author&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// BaseClasses - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// ClassifierID - Not included (Relational)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;ClassifierName&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.ClassifierName = EXCELIGetColumnValueByName(&quot;ClassifierName&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// ClassifierType - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Complexity&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Complexity = EXCELIGetColumnValueByName(&quot;Complexity&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// CompositeDiagram - Not included (Relational)&#xA;&#x9;&#x9;&#x9;// Connectors - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Constraints - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// ConstraintsEx - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Created&quot;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;var dateString = EXCELIGetColumnValueByName(&quot;Created&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;var asEADate = DTParseEADate( dateString );&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Created = asEADate;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// CustomProperties - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Diagrams - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Difficulty&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Difficulty = EXCELIGetColumnValueByName(&quot;Difficulty&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Efforts - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// ElementGUID - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// ElementID - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// Elements - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// EmbeddedElements - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// EventFlags - Not included (Comma Separated)&#x9;&#xA;&#x9;&#x9;&#x9;// ExtensionPoints - Not included (Comma Separated)&#xA;&#x9;&#x9;&#x9;// Files - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;GenFile&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Genfile = EXCELIGetColumnValueByName(&quot;GenFile&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Genlinks - Not included (Relational)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;GenType&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Gentype = EXCELIGetColumnValueByName(&quot;GenType&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Header1&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Header1 = EXCELIGetColumnValueByName(&quot;Header1&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Header2&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Header1 = EXCELIGetColumnValueByName(&quot;Header2&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;IsActive&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.IsActive = EXCELIGetColumnValueByName(&quot;IsActive&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;IsLeaf&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.IsLeaf = EXCELIGetColumnValueByName(&quot;IsLeaf&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;IsNew&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.IsNew = EXCELIGetColumnValueByName(&quot;IsNew&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;IsSpec&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.IsSpec = EXCELIGetColumnValueByName(&quot;IsSpec&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Issues - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Locked&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Locked = EXCELIGetColumnValueByName(&quot;Locked&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// MetaType - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// Methods - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Metrics - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// MiscData - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// Modified - Not included (Overwritten)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Multiplicity&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Multiplicity = EXCELIGetColumnValueByName(&quot;Multiplicity&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Name&quot;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Name = EXCELIGetColumnValueByName(&quot;Name&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Notes&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Notes = EXCELIGetColumnValueByName(&quot;Notes&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// ObjectType - Not included (Read Only)&#xA;&#x9;&#x9;&#x9;// PackageID - Not included (Relational)&#xA;&#x9;&#x9;&#x9;// ParentID - Not included (Relational)&#xA;&#x9;&#x9;&#x9;// Partitions - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Persistence&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Persistence = EXCELIGetColumnValueByName(&quot;Persistence&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Phase&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Persistence = EXCELIGetColumnValueByName(&quot;Phase&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Priority&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Persistence = EXCELIGetColumnValueByName(&quot;Priority&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Properties - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// PropertyType - Not included (Relational)&#xA;&#x9;&#x9;&#x9;// Realizes - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Requirements - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// RequirementsEx - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Resources - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Risks - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;RunState&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Persistence = EXCELIGetColumnValueByName(&quot;RunState&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// Scenarios - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// State Transitions - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Status&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Status = EXCELIGetColumnValueByName(&quot;Status&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Stereotype&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Stereotype = EXCELIGetColumnValueByName(&quot;Stereotype&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// StereotypeEx - Not included (Comma Separated)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Subtype&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Subtype = EXCELIGetColumnValueByName(&quot;Subtype&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Tablespace&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Tablespace = EXCELIGetColumnValueByName(&quot;Tablespace&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Tag&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Tag = EXCELIGetColumnValueByName(&quot;Tag&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;// TaggedValues - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// TaggedValuesEx - Not included (Collection)&#xA;&#x9;&#x9;&#x9;// Tests - Not included (Collection)&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (EXCELIContainsColumn(&quot;TreePos&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.TreePos = EXCELIGetColumnValueByName(&quot;TreePos&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Type&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Type = EXCELIGetColumnValueByName(&quot;Type&quot;);&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Version&quot;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Version = EXCELIGetColumnValueByName(&quot;Version&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Visibility&quot;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Visibility = EXCELIGetColumnValueByName(&quot;Visibility&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. EXCELISetStandardElementFieldValues() should only be called from within OnExcelRowImported()&quot; );&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * @private&#xA; * Returns the index of the column with the specified name&#xA; *&#xA; * @param[in] columnName (String) The name of the column whose index will be retrieved&#xA; *&#xA; * @return The index of the column with the specified name&#xA; */&#xA;function __EXCELIGetColumnNumber( columnName /* : String */ ) /* : number */&#xA;{&#xA;&#x9;var result = -1;&#xA;&#x9;if ( excelImportColumnMap != null &amp;&amp; excelImportColumnMap.has(columnName) ) {&#xA;&#x9;&#x9;result = excelImportColumnMap.get(columnName);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;return result;&#xA;}&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;EXCEL EXPORT&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;let exportRow            = 1;&#x9;&#x9;// : Integer with the value for the current Row to export to&#xA;let exportHeaderRow      = 0;&#x9;&#x9;// : Integer with the value for the header Row to export to&#xA;let exportColumns        = null;&#x9;// : Array with column headers to export&#xA;let exportExcelWorkSheet = null;&#xA;let exportIsExporting    = false;&#xA;&#xA;/**&#xA; * Initialises a EXCEL Export session. This must be called before calls to EXCELEExportRow() are made. &#xA; * Once all rows have been exported, a corresponding call to EXCELEExportFinalize() should be made.&#xA; *&#xA; * @param[in] sheetName (string) The name of the Worksheet in the EXCEL file to export the values to.&#xA; * @param[in] columns (Array) an array of column names that will be exported&#xA; * @param[in] exportColumnHeadings (boolean) Specifies whether the first row should contain the column &#xA; * headings&#xA; */&#xA;function EXCELEExportInitialize( sheetName /* : String */, columns /* : Array */, &#xA;&#x9;exportColumnHeadings /* : boolean */ ) /* : void */&#xA;{&#xA;&#xA;&#x9;if ( !exportIsExporting )&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;// Check if Worksheet successfully opened for writing&#xA;&#x9;&#x9;if ( objExcelWorkBook == null ) {&#xA;&#x9;&#x9;&#x9;// objExcelWorkBook NOT FOUND&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEExportInitialize Could NOT get Worksheet &quot; + sheetName + &quot;, because objExcelWorkBook NOT opened!&quot; );&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Switch into exporting mode&#xA;&#x9;&#x9;exportIsExporting = true;&#xA;&#xA;&#x9;&#x9;// Setup column array&#xA;&#x9;&#x9;exportColumns = columns;&#xA;&#xA;&#x9;&#x9;// Get and check the exportExcelWorkSheet for sheetName&#xA;&#x9;&#x9;exportExcelWorkSheet  = EXCELWGetWorksheet( sheetName, true );&#xA;&#x9;&#x9;if ( exportExcelWorkSheet != null ) {&#xA;&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;// Clear the exportExcelWorkSheet before exporting the new values&#xA;&#x9;&#x9;&#x9;&#x9;let RowCount    = exportExcelWorkSheet.UsedRange.Rows.Count;&#xA;&#x9;&#x9;&#x9;&#x9;let ColumnCount = exportExcelWorkSheet.UsedRange.Columns.Count;&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELEExportInitialize exportExcelWorkSheet.UsedRange to clear: (&quot; + RowCount + &quot;,&quot; + ColumnCount + &quot;)!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;exportExcelWorkSheet.UsedRange.Clear();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Check if headers should be exported&#xA;&#x9;&#x9;&#x9;&#x9;if ( exportColumnHeadings )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Get the header information from the current exportRow&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportHeaderRow = exportRow;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for ( var curCol = 1 ; curCol &lt;= exportColumns.length ; curCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;exportExcelWorkSheet.Cells.Item( exportHeaderRow, curCol ).Value = exportColumns[ curCol - 1 ];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportRow++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEExportInitialize catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEExportInitialize did NOT find sheetName &quot; + sheetName + &quot;!&quot;  );&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;EXCELEExportInitialize: EXCEL Export is already in progress&quot; );&#xA;&#x9;&#x9;return null;&#xA;&#x9;}&#xA;&#xA;&#x9;// Session.Output( &quot;EXCELEExportInitialize exportRow = &quot; + exportRow + &quot;!!!&quot; );&#xA;&#xA;&#x9;return exportExcelWorkSheet;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Add new columns to the columns already defined.&#xA; * Check for duplicates.&#xA; */&#xA;function EXCELEAddExportColumns( columns /* : Array */ ) /* : Void */&#xA;{&#xA;&#x9;// Check whether exportIsExporting and exportHeaderRow used&#xA;&#x9;if ( ( exportIsExporting ) &amp;&amp; ( exportHeaderRow &gt; 0 ) )&#xA;&#x9;{&#xA;&#x9;&#x9;try {&#xA;&#xA;&#x9;&#x9;&#x9;let columnArray       = [];&#xA;&#x9;&#x9;&#x9;let exportColumnToAdd = exportColumns.length;&#xA;&#xA;&#x9;&#x9;&#x9;// Setup column array&#xA;&#x9;&#x9;&#x9;columnArray = columns;&#xA;&#xA;&#x9;&#x9;&#x9;// Extend row/column caching&#xA;&#x9;&#x9;&#x9;for ( var curCol = 1 ; curCol &lt;= columnArray.length ; curCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;let exportColumnText = columnArray[ curCol - 1 ];&#xA;&#x9;&#x9;&#x9;&#x9;let duplicateFound   = false;&#xA;&#x9;&#x9;&#x9;&#x9;// Check current exportColumns to prevent duplicates&#xA;&#x9;&#x9;&#x9;&#x9;for ( var curExCol = 0 ; curExCol &lt; exportColumns.length ; curExCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ( exportColumns[ curExCol ] == exportColumnText ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;duplicateFound = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;// Only add new column when not duplicateFound&#xA;&#x9;&#x9;&#x9;&#x9;if ( ! duplicateFound ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportColumnToAdd++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportColumns.push( exportColumnText );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportExcelWorkSheet.Cells.Item( exportHeaderRow, exportColumnToAdd ).Value = exportColumnText;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEAddExportColumns catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;EXCELEAddExportColumns: EXCEL Export is not currently in progress&quot; );&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Finalizes an EXCEL Export session, closing file system resources required for the export. After this&#xA; * function has been executed, further calls to EXCELEExportRow() will fail until another EXCEL Export&#xA; * session is initialized via EXCELEExportInitialize()&#xA; */&#xA;function EXCELEExportFinalize() /* : void */&#xA;{&#xA;&#x9;if ( exportIsExporting )&#xA;&#x9;{&#xA;&#x9;&#x9;// Clean up column array&#xA;&#x9;&#x9;exportColumns = null;&#xA;&#xA;&#x9;&#x9;// Switch out of exporting mode&#xA;&#x9;&#x9;exportIsExporting = false;&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;EXCELEExportFinalize: EXCEL Export is not currently in progress&quot; );&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Exports a row to the EXCEL file. The valueMap parameter is used to lookup field values for the&#xA; * columns specified when EXCELEExportInitialize() was called. Values in valueMap that do not &#xA; * correspond to a valid column will not be exported.&#xA; *&#xA; * @param[in] valueMap (Map) A Map of field values where key=Column Name, value=Field Value&#xA; */&#xA;&#xA;function EXCELEExportRow( valueMap /* : Map */ ) /* : void */&#xA;{&#xA;&#x9;if ( exportIsExporting )&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;// Check if Worksheet successfully opened for writing&#xA;&#x9;&#x9;if ( exportExcelWorkSheet == null ) {&#xA;&#x9;&#x9;&#x9;// exportExcelWorkSheet NOT FOUND&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEExportRow Could NOT export row because exportExcelWorkSheet NOT opened!&quot; );&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;try {&#xA;&#xA;&#x9;&#x9;&#x9;if ( exportColumns.length &gt; 0 )&#xA;&#x9;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Iterate over all columns specified in EXCELEExportInitialize()&#xA;&#x9;&#x9;&#x9;&#x9;for ( let curCol = 1 ; curCol &lt;= exportColumns.length ; curCol++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Get the column name&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let currentColumn = exportColumns[ curCol - 1 ];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Get the corresponding field value from valueMap&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let fieldValue = valueMap.get( currentColumn );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// If the fieldValue is null/undefined, output an empty string&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ( fieldValue == null ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fieldValue = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;exportExcelWorkSheet.Cells.Item( exportRow, curCol ).Value = __EXCELEToSafeEXCELString( fieldValue );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Prepare the exportRow for the next export&#xA;&#x9;&#x9;&#x9;&#x9;exportRow++;&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;EXCELEExportRow exportRow = &quot; + exportRow + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;EXCELEExportRow catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;EXCEL Export is not currently in progress. Call EXCELEExportInitialize() to start a EXCEL Export&quot; );&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Creates and returns an empty Value Map.&#xA; */&#xA;function EXCELECreateEmptyValueMap() /* : Map */&#xA;{&#xA;&#x9;var valueMap = new Map();&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * Returns an array of column names considered standard for EA elements. This array can be used&#xA; * as the columns parameter when calling EXCELEExportInitialize()&#xA; *&#xA; * @param[in] includeGUID (boolean) Advises whether the elementGUID field should be included&#xA; *&#xA; * @return an array of column names &#xA; */&#xA;function EXCELEGetStandardElementColumns( includeGUID /* : boolean */ ) /* : Array */&#xA;{&#xA;&#x9;var columnArray = [];&#xA;&#x9;&#xA;&#x9;columnArray.push( &quot;Abstract&quot; );&#xA;&#x9;// ActionFlags - Not included (Comma Separated)&#x9;&#xA;&#x9;columnArray.push( &quot;Alias&quot; );&#xA;&#x9;// Attributes - Not included (Collection)&#xA;&#x9;// AttributesEx - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Author&quot; );&#xA;&#x9;// BaseClasses - Not included (Collection)&#xA;&#x9;// ClassifierID - Not included (Relational)&#xA;&#x9;columnArray.push( &quot;ClassifierName&quot; );&#xA;&#x9;// ClassifierType - Not included (Read Only)&#xA;&#x9;columnArray.push(  &quot;Complexity&quot; );&#xA;&#x9;// CompositeDiagram - Not included (Relational)&#xA;&#x9;// Connectors - Not included (Collection)&#xA;&#x9;// Constraints - Not included (Collection)&#xA;&#x9;// ConstraintsEx - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Created&quot; );&#xA;&#x9;// CustomProperties - Not included (Collection)&#xA;&#x9;// Diagrams - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Difficulty&quot; );&#xA;&#x9;// Efforts - Not included (Collection)&#xA;&#x9;&#xA;&#x9;if ( includeGUID ) {&#xA;&#x9;&#x9;columnArray.push( &quot;ElementGUID&quot; );&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;// Elements - Not included (Collection)&#xA;&#x9;// EmbeddedElements - Not included (Collection)&#xA;&#x9;// EventFlags - Not included (Comma Separated)&#xA;&#x9;// ExtensionPoints - Not included (Comma Separated)&#xA;&#x9;// Files - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;GenFile&quot; );&#xA;&#x9;// Genlinks - Not included (Relational)&#xA;&#x9;columnArray.push( &quot;GenType&quot; );&#xA;&#x9;columnArray.push( &quot;Header1&quot; );&#xA;&#x9;columnArray.push( &quot;Header2&quot; );&#xA;&#x9;columnArray.push( &quot;IsActive&quot; );&#xA;&#x9;columnArray.push( &quot;IsLeaf&quot; );&#xA;&#x9;columnArray.push( &quot;IsNew&quot; );&#xA;&#x9;columnArray.push( &quot;IsSpec&quot; );&#xA;&#x9;// Issues - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Locked&quot; );&#xA;&#x9;// MetaType - Not included (Read Only)&#xA;&#x9;// Methods - Not included (Collection)&#xA;&#x9;// Metrics - Not included (Collection)&#xA;&#x9;// MiscData - Not included (Read Only)&#xA;&#x9;// Modified - Not included (Overwritten)&#xA;&#x9;columnArray.push( &quot;Multiplicity&quot; );&#xA;&#x9;columnArray.push( &quot;Name&quot; );&#xA;&#x9;columnArray.push( &quot;Notes&quot; );&#xA;&#x9;// ObjectType - Not included (Read Only)&#xA;&#x9;// PackageID - Not included (Relational)&#xA;&#x9;// ParentID - Not included (Relational)&#xA;&#x9;// Partitions - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Persistence&quot; );&#xA;&#x9;columnArray.push( &quot;Phase&quot; );&#xA;&#x9;columnArray.push( &quot;Priority&quot; );&#xA;&#x9;// Properties - Not included (Collection)&#xA;&#x9;// PropertyType - Not included (Relational)&#xA;&#x9;// Realizes - Not included (Collection)&#xA;&#x9;// Requirements - Not included (Collection)&#xA;&#x9;// RequirementsEx - Not included (Collection)&#xA;&#x9;// Resources - Not included (Collection)&#xA;&#x9;// Risks - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;RunState&quot; );&#xA;&#x9;// Scenarios - Not included (Collection)&#xA;&#x9;// State Transitions - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;Status&quot; );&#xA;&#x9;columnArray.push( &quot;Stereotype&quot; );&#xA;&#x9;// StereotypeEx - Not included (Comma Separated)&#x9;&#xA;&#x9;columnArray.push( &quot;Subtype&quot; );&#xA;&#x9;columnArray.push( &quot;Tablespace&quot; );&#xA;&#x9;columnArray.push( &quot;Tag&quot; );&#xA;&#x9;// TaggedValues - Not included (Collection)&#xA;&#x9;// TaggedValuesEx - Not included (Collection)&#xA;&#x9;// Tests - Not included (Collection)&#xA;&#x9;columnArray.push( &quot;TreePos&quot; );&#xA;&#x9;columnArray.push( &quot;Type&quot; );&#xA;&#x9;columnArray.push( &quot;Version&quot; );&#xA;&#x9;columnArray.push( &quot;Visibility&quot; );&#xA;&#x9;&#xA;&#x9;return columnArray;&#xA;}&#xA;&#xA;/**&#xA; * Creates a Value Map of standard property names/values for the specified element. This Value Map &#xA; * can be used as the valueMap parameter when calling the ExportRow() function.&#xA; *&#xA; * @param[in] element (EA.Element) The element to compile the Value Map for&#xA; *&#xA; * @return A Value Map populated with the provided element's values.&#xA; */&#xA;function EXCELEGetStandardElementFieldValues( element /* : EA.Element */ ) /* : Map */&#xA;{&#xA;&#xA;&#x9;let valueMap = EXCELECreateEmptyValueMap();&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;var theElement as EA.Element;&#xA;&#x9;&#x9;theElement = element;&#xA;&#xA;&#x9;&#x9;valueMap.set( &quot;Abstract&quot;, theElement.Abstract );&#xA;&#x9;&#x9;// ActionFlags - Not included (Comma Separated)&#xA;&#x9;&#x9;valueMap.set( &quot;Alias&quot;, theElement.Alias );&#xA;&#x9;&#x9;// Attributes - Not included (Collection)&#xA;&#x9;&#x9;// AttributesEx - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Author&quot;, theElement.Author );&#xA;&#x9;&#x9;// BaseClasses - Not included (Collection)&#xA;&#x9;&#x9;// ClassifierID - Not included (Relational)&#xA;&#x9;&#x9;valueMap.set( &quot;ClassifierName&quot;, theElement.ClassifierName );&#xA;&#x9;&#x9;// ClassifierType - Not included (Read Only)&#xA;&#x9;&#x9;valueMap.set( &quot;Complexity&quot;, theElement.Complexity);&#xA;&#x9;&#x9;// CompositeDiagram - Not included (Relational)&#xA;&#x9;&#x9;// Connectors - Not included (Collection)&#xA;&#x9;&#x9;// Constraints - Not included (Collection)&#xA;&#x9;&#x9;// ConstraintsEx - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Created&quot;, theElement.Created );&#xA;&#x9;&#x9;// CustomProperties - Not included (Collection)&#xA;&#x9;&#x9;// Diagrams - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Difficulty&quot;, theElement.Difficulty );&#xA;&#x9;&#x9;// Efforts - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;ElementGUID&quot;, theElement.ElementGUID );&#xA;&#x9;&#x9;// Elements - Not included (Collection)&#xA;&#x9;&#x9;// EmbeddedElements - Not included (Read Only)&#xA;&#x9;&#x9;// Event Flags - Not included (Comma Separated)&#x9;&#xA;&#x9;&#x9;// ExtensionPoints - Not included (Comma Separated)&#xA;&#x9;&#x9;// Files - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;GenFile&quot;, theElement.Genfile );&#xA;&#x9;&#x9;// Genlinks - Not included (Relational)&#xA;&#x9;&#x9;valueMap.set( &quot;GenType&quot;, theElement.Gentype );&#xA;&#x9;&#x9;valueMap.set( &quot;Header1&quot;, theElement.Header1 );&#xA;&#x9;&#x9;valueMap.set( &quot;Header2&quot;, theElement.Header2 );&#xA;&#x9;&#x9;valueMap.set( &quot;IsActive&quot;, theElement.IsActive );&#xA;&#x9;&#x9;valueMap.set( &quot;IsLeaf&quot;, theElement.IsLeaf );&#xA;&#x9;&#x9;valueMap.set( &quot;IsNew&quot;, theElement.IsNew );&#xA;&#x9;&#x9;valueMap.set( &quot;IsSpec&quot;, theElement.IsSpec );&#xA;&#x9;&#x9;// Issues - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Locked&quot;, theElement.Locked );&#xA;&#x9;&#x9;// MetaType - Not included (Read Only)&#xA;&#x9;&#x9;// Methods - Not included (Collection)&#xA;&#x9;&#x9;// Metrics - Not included (Collection)&#xA;&#x9;&#x9;// MiscData - Not included (Read Only)&#xA;&#x9;&#x9;// Modified - Not included (Overwritten)&#xA;&#x9;&#x9;valueMap.set( &quot;Multiplicity&quot;, theElement.Multiplicity );&#xA;&#x9;&#x9;valueMap.set( &quot;Name&quot;, theElement.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;Notes&quot;, theElement.Notes );&#xA;&#x9;&#x9;// ObjectType - Not included (Read Only)&#xA;&#x9;&#x9;// PackageID - Not included (Relational)&#xA;&#x9;&#x9;// ParentID - Not included (Relational)&#xA;&#x9;&#x9;// Partitions - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Persistence&quot;, theElement.Persistence );&#xA;&#x9;&#x9;valueMap.set( &quot;Phase&quot;, theElement.Phase );&#xA;&#x9;&#x9;valueMap.set( &quot;Priority&quot;, theElement.Priority );&#xA;&#x9;&#x9;// Properties - Not included (Collection)&#xA;&#x9;&#x9;// PropertyType - Not included (Relational)&#xA;&#x9;&#x9;// Realizes - Not included (Collection)&#xA;&#x9;&#x9;// Requirements - Not included (Collection)&#xA;&#x9;&#x9;// RequirementsEx - Not included (Collection)&#xA;&#x9;&#x9;// Resources - Not included (Collection)&#xA;&#x9;&#x9;// Risks - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;RunState&quot;, theElement.RunState );&#xA;&#x9;&#x9;// Scenarios - Not included (Collection)&#xA;&#x9;&#x9;// State Transitions - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;Status&quot;, theElement.Status );&#xA;&#x9;&#x9;valueMap.set( &quot;Stereotype&quot;, theElement.Stereotype );&#xA;&#x9;&#x9;// StereotypeEx - Not included (Comma Separated)&#x9;&#xA;&#x9;&#x9;valueMap.set( &quot;Subtype&quot;, theElement.Subtype );&#xA;&#x9;&#x9;valueMap.set( &quot;Tablespace&quot;, theElement.Tablespace );&#xA;&#x9;&#x9;valueMap.set( &quot;Tag&quot;, theElement.Tag );&#xA;&#x9;&#x9;// TaggedValues - Not included (Collection)&#xA;&#x9;&#x9;// TaggedValuesEx - Not included (Collection)&#xA;&#x9;&#x9;// Tests - Not included (Collection)&#xA;&#x9;&#x9;valueMap.set( &quot;TreePos&quot;, theElement.TreePos );&#xA;&#x9;&#x9;valueMap.set( &quot;Type&quot;, theElement.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;Version&quot;, theElement.Version );&#xA;&#x9;&#x9;valueMap.set( &quot;Visibility&quot;, theElement.Visibility );&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;EXCELEGetStandardElementFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;valueMap = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * @private&#xA; * Returns a copy of the string that is safe for inclusion in a EXCEL file.&#xA; *&#xA; * @param[in] originalString (String) The string to convert&#xA; *&#xA; * @return a copy of the string modified for inclusion in a EXCEL file&#xA; */&#xA;function __EXCELEToSafeEXCELString( originalString /* : String */ ) /* : String */&#xA;{&#xA;&#x9;var returnString = new String(originalString);&#xA;&#x9;&#xA;&#x9;// Strip out delimiters&#xA;&#x9;var delimiterRegExp = new RegExp( EXCEL_DELIMITER, &quot;gm&quot; );&#xA;&#x9;returnString = returnString.replace( delimiterRegExp, &quot;&quot; );&#xA;&#x9;&#xA;&#x9;// Strip out newline chars&#xA;&#x9;var newlineRegExp = new RegExp( &quot;\r\n?&quot;, &quot;gm&quot; );&#xA;&#x9;returnString = returnString.replace( newlineRegExp, &quot; &quot; );&#xA;&#x9;&#x9;&#xA;&#x9;return returnString;&#xA;}&#xA;" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="21" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{F7D8D97F-B2B8-43e3-A9A1-84DE5056AB92}" />
			<Column name="ScriptAuthor" value="{FD8D9BCA-EA60-4047-A4C5-6DE6E568DB04}" />
			<Column name="Notes" value="&lt;Script Name=&quot;JavaScript-ImEx&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatScriptLib]&#xA;!INC EAScriptLib.JavaScript-Logging&#xA;!INC EAScriptLib.JavaScript-TaggedValue&#xA;&#xA;&#xA;/**&#xA; * @file JavaScript-ImEx&#xA; * This script library contains helper functions to assist with IMEX Import and Export of&#xA; * Enterprise Architect Elements and Connectors using an Excel Workbook file.&#xA; * This functionality is similar to the eaexcelimporter of Geert Bellekens. &#xA; * &#xA; * Functions in this library are split into three parts: Workbooks, Import and Export.&#xA; * Functions that assist with IMEX Workbooks are prefixed with IMEXW,&#xA; * IMEX Import Functions are prefixed with IMEXI and IMEX Export Functions are prefixed with IMEXE.&#xA; *&#xA; * IMEX Import can be performed by calling the function IMEXIHandleExcelImport().&#xA; * IMEXIHandleExcelImport() requires the name of the WorkSheet containing the information and&#xA; * that the function OnExcelRowImported() is defined in the user's script to be used as a callback&#xA; * whenever row data is read from the IMEX file. The user defined OnExcelRowImported() can query for &#xA; * information about the current row through the functions EXCELIContainsColumn(), &#xA; * EXCELIGetColumnValueByName() and EXCELIGetColumnValueByNumber().&#xA; *&#xA; * To perform an IMEX export, the user must call IMEXEHandleExcelExport() which starts an export &#xA; * session. The call to IMEXEHandleExcelExport() specifies the file name to export to, and the set of &#xA; * columns that will be exported. Once the session has been initialized with a call to &#xA; * IMEXEExportInitialize(), the user may continually call IMEXEExportRow() to export a row to file. &#xA; * Once all rows have been added, the export session is closed by calling IMEXEExportFinalize(). &#xA; *&#xA; * @author J. de Baat, based on JavaScript - CSV by Sparx Systems&#xA; * @date 2024-07-13&#xA; */&#xA;&#xA;const strGlobalEAPackageName        = &quot;ImEx Package&quot;;&#xA;const strGlobalEADiagramName        = &quot;ImEx Diagram&quot;;&#xA;const strDefaultElementsFileName    = &quot;ImExElements.xlsx&quot;;&#xA;const strDefaultConnectorsFileName  = &quot;ImExConnectors.xlsx&quot;;&#xA;const strDefaultElementsSheetName   = &quot;ImEx_Elements&quot;;&#xA;const strDefaultConnectorsSheetName = &quot;ImEx_Connectors&quot;;&#xA;const strTaggedValuesPrefix         = &quot;TAG_&quot;;&#xA;const strNoClientConnector          = &quot;ImEx_NoClientConnector&quot;;&#xA;&#xA;const strImExStartPackage           = &quot;Package&quot;;&#xA;const strImExStartDiagram           = &quot;Diagram&quot;;&#xA;let   strImExStart                  = &quot;None&quot;;&#xA;&#xA;const ConnectorArchiMateAssociation = 0;&#xA;const ConnectorArchiMateAggregation = 1;&#xA;const ConnectorArchiMateComposition = 2;&#xA;const ConnectorDirectionUnspecified = &quot;Unspecified&quot;;&#xA;&#xA;const strArchiMatePrefix            = &quot;ArchiMate_&quot;;&#xA;const strArchiMate3Prefix           = &quot;ArchiMate3::&quot;;&#xA;&#xA;/**&#xA; * objGlobalEAPackage needs to have a objGlobalEADiagram and visa versa.&#xA; */&#xA;var objGlobalEAPackage as EA.Package;&#xA;var objGlobalEADiagram as EA.Diagram;&#xA;&#xA;/**&#xA; * If theValue starts with thePrefix then return value without prefix else return empty string&#xA; *&#xA; * @param[in] theValue (string) The value to test.&#xA; * @param[in] thePrefix (string) The prefix to test against.&#xA; */&#xA;function IMEXGGetValueWithoutPrefix( theValue, thePrefix )&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;const thePrefixLength = thePrefix.length;&#xA;&#x9;&#x9;// Session.Output(&quot;IMEXGGetValueWithoutPrefix started with thePrefix : &quot; + thePrefix + &quot;, length = &quot; + thePrefixLength + &quot; !&quot; );&#xA;&#xA;&#x9;&#x9;//&#x9;If theValue starts with thePrefix then return value without prefix&#xA;&#x9;&#x9;if ( theValue.substring( 0, thePrefixLength ).toLowerCase() == thePrefix.toLowerCase() ) {&#xA;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXGGetValueWithoutPrefix found theValue.substring(&quot; + thePrefixLength + &quot;)= &quot; + theValue.substring( thePrefixLength ) + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;return theValue.substring( thePrefixLength );&#xA;&#x9;&#x9;}&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGGetValueWithoutPrefix catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Check whether theStereotype starts with ArchiMate_ and should be prefixed with ArchiMate3::&#xA; */&#xA;function IMEXGCheckArchiMateStereotype( theStereotype )&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;let curStereotype = theStereotype;&#xA;&#xA;&#x9;&#x9;// Check whether theStereotype is available&#xA;&#x9;&#x9;if ( curStereotype == null ) {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;IMEXGCheckArchiMateStereotype( &quot; + theStereotype + &quot; ) DID NOT update theStereotype to &quot; + curStereotype + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;return curStereotype;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Check whether theStereotype should be prefixed&#xA;&#x9;&#x9;if ( curStereotype.substring( 0, strArchiMatePrefix.length ).toLowerCase() == strArchiMatePrefix.toLowerCase() ) {&#xA;&#x9;&#x9;&#x9;curStereotype = strArchiMate3Prefix + curStereotype;&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;IMEXGCheckArchiMateStereotype( &quot; + theStereotype + &quot; ) updated theStereotype to &quot; + curStereotype + &quot;!!!&quot; );&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;// Session.Output(&quot;IMEXGCheckArchiMateStereotype( &quot; + theStereotype + &quot; ) DID NOT update theStereotype to &quot; + curStereotype + &quot;!!!&quot; );&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;return curStereotype;&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGCheckArchiMateStereotype catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;return theStereotype;&#xA;&#x9;}&#xA;}&#xA;&#xA;/*&#xA; * Check theStereotype to define the ClientEnd.Aggregation&#xA; */&#xA;function IMEXGCheckArchiMateStereotypeConnector( theStereotype )&#xA;{&#xA;&#xA;&#x9;// Check whether theStereotype is available&#xA;&#x9;if ( theStereotype == null ) {&#xA;&#x9;&#x9;return ConnectorArchiMateAssociation;&#xA;&#x9;}&#xA;&#xA;&#x9;// Check what to use as Starting point for export&#xA;&#x9;switch ( theStereotype ) {&#xA;&#x9;&#x9;case &quot;ArchiMate_Aggregation&quot; :&#xA;&#x9;&#x9;case &quot;ArchiMate3::ArchiMate_Aggregation&quot; :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Set to show as ArchiMate_Aggregation&#xA;&#x9;&#x9;&#x9;return ConnectorArchiMateAggregation;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case &quot;ArchiMate_Composition&quot; :&#xA;&#x9;&#x9;case &quot;ArchiMate3::ArchiMate_Composition&quot; :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Set to show as ArchiMate_Composition&#xA;&#x9;&#x9;&#x9;return ConnectorArchiMateComposition;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Set to show as default Association&#xA;&#x9;&#x9;&#x9;return ConnectorArchiMateAssociation;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return ConnectorArchiMateAssociation;&#xA;}&#xA;&#xA;/*&#xA; * Check theStereotype to define the ClientEnd.Aggregation&#xA; */&#xA;function IMEXGCheckConnectorDirection( theConnector, theDirection )&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;// Cast theConnector to EA.Connector so we get intellisense&#xA;&#x9;&#x9;var curConnector       as EA.Connector;&#xA;&#x9;&#x9;curConnector            = theConnector;&#xA;&#xA;&#x9;&#x9;// Check whether theConnector and theStereotype are available&#xA;&#x9;&#x9;if ( ( theConnector == null ) || ( theDirection == null ) ) {&#xA;&#x9;&#x9;&#x9;return;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Check what to use as Starting point for export&#xA;&#x9;&#x9;switch ( theDirection ) {&#xA;&#x9;&#x9;&#x9;case &quot;Source -&gt; Destination&quot; :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Set the SupplierEnd as Navigable&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.IsNavigable = false;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.IsNavigable = true;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;case &quot;Destination -&gt; Source&quot; :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Set the ClientEnd as Navigable&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.IsNavigable = true;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.IsNavigable = false;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;case &quot;Bi-Directional&quot; :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Set both the ClientEnd and SupplierEnd as Navigable&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.IsNavigable = true;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.IsNavigable = true;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;case &quot;Unspecified&quot; :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Set both the ClientEnd and SupplierEnd as Navigable&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.IsNavigable = false;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.IsNavigable = false;&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.SupplierEnd.Update();&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Do nothing&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;// Session.Output( &quot;IMEXGCheckConnectorDirection curConnector(&quot; + curConnector.Name + &quot;).Direction set to &quot; + curConnector.Direction + &quot; based on &quot; + EXCELIGetColumnValueByName(&quot;Direction&quot;) + &quot;, Navigable: ClientEnd= &quot; + curConnector.ClientEnd.Navigable + &quot;, SupplierEnd= &quot; + curConnector.SupplierEnd.Navigable + &quot;!!!&quot; );&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGCheckConnectorDirection catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;}&#xA;}&#xA;&#xA;/*&#xA; * Add a new PackageDiagram if it is not defined yet&#xA; */&#xA;function IMEXGCheckOrAddPackageDiagram( thePackage, thePackageDiagramName )&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;// Validate input parameters&#xA;&#x9;&#x9;if ( ( thePackage != null ) &amp;&amp; ( thePackageDiagramName != &quot;&quot; ) ) {&#xA;&#xA;&#x9;&#x9;&#x9;var curPackage  as EA.Package;&#xA;&#x9;&#x9;&#x9;var curDiagrams as EA.Collection;&#xA;&#x9;&#x9;&#x9;var curDiagram  as EA.Diagram;&#xA;&#xA;&#x9;&#x9;&#x9;// Check all Diagrams in thePackage whether the requested thePackageDiagramName already exists&#xA;&#x9;&#x9;&#x9;curPackage  = thePackage;&#xA;&#x9;&#x9;&#x9;curDiagrams = curPackage.Diagrams;&#xA;&#x9;&#x9;&#x9;curDiagram  = curDiagrams.GetByName( thePackageDiagramName );&#xA;&#xA;&#x9;&#x9;&#x9;// If curDiagram is not found, create a new diagram&#xA;&#x9;&#x9;&#x9;if ( curDiagram == null )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;CheckOrAddPackageDiagram addNew because not found: &quot; + thePackageDiagramName );&#xA;&#x9;&#x9;&#x9;&#x9;curDiagram = curDiagrams.AddNew( thePackageDiagramName, &quot;Logical&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;curDiagram.Notes = thePackageDiagramName + &quot; created by JavaScript-ImEx library.&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;curDiagram.Update();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;curDiagrams.Refresh();&#xA;&#x9;&#x9;&#x9;&#x9;curPackage.Update();&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Session.Output( &quot;CheckOrAddPackageDiagram found &quot; + curDiagram.Name + &quot; as part of PackageID=&quot; + thePackage.PackageID + &quot; !&quot; );&#xA;&#x9;&#x9;&#x9;return curDiagram;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;CheckOrAddPackageDiagram could NOT add PackageDiagram &quot; + thePackageDiagramName + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGCheckOrAddPackageDiagram catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;return null;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Get and check the global variables&#xA; */&#xA;function IMEXGGetAndCheckGlobalVariables()&#xA;{&#xA;&#xA;&#x9;//&#x9;Check objGlobalEAPackage and objGlobalEADiagram&#xA;&#x9;if ( ( objGlobalEAPackage == null ) &amp;&amp; ( objGlobalEADiagram == null ) ) {&#xA;&#x9;&#x9;LOGError( &quot;Either objGlobalEAPackage OR objGlobalEADiagram should be available!&quot; );&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;//&#x9;Check objGlobalEADiagram, get it from objGlobalEAPackage which should not be nothing&#xA;&#x9;if ( objGlobalEADiagram == null ) {&#xA;&#x9;&#x9;objGlobalEADiagram = IMEXGCheckOrAddPackageDiagram( objGlobalEAPackage, strGlobalEADiagramName );&#xA;&#x9;&#x9;// Session.Output( &quot;GetAndCheckGlobalVariables found &quot; + objGlobalEADiagram.Name + &quot; as part of objGlobalEAPackage &quot; + objGlobalEAPackage.Name + &quot; !&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;//&#x9;Check objGlobalEAPackage, get it from objGlobalEADiagram which should not be nothing&#xA;&#x9;if ( objGlobalEAPackage == null ) {&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;objGlobalEAPackage = Repository.GetPackageByID( objGlobalEADiagram.PackageID );&#xA;&#x9;&#x9;&#x9;// Session.Output( &quot;GetAndCheckGlobalVariables found &quot; + objGlobalEAPackage.Name + &quot; as parent of objGlobalEADiagram &quot; + objGlobalEADiagram.Name + &quot; !&quot; );&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;IMEXGGetAndCheckGlobalVariables catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;objGlobalEAPackage = null;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;//&#x9;Check objGlobalEAPackage and objGlobalEADiagram again&#xA;&#x9;if ( ( objGlobalEAPackage == null ) || ( objGlobalEADiagram == null ) ) {&#xA;&#x9;&#x9;LOGError( &quot;Both objGlobalEAPackage AND objGlobalEADiagram should be available!&quot; );&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;return true;&#xA;}&#xA;&#xA;/*&#xA; * Get and check the global variables for a Project Browser Script&#xA; */&#xA;function IMEXGGetAndCheckPackageObject()&#xA;{&#xA;&#xA;&#x9;// Prepare some global variables&#xA;&#x9;objGlobalEAPackage = null;&#xA;&#x9;objGlobalEADiagram = null;&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;// Get the type of element selected in the Project Browser&#xA;&#x9;&#x9;let treeSelectedType = Repository.GetTreeSelectedItemType();&#xA;&#xA;&#x9;&#x9;// Handling Code: Uncomment any types you wish this script to support&#xA;&#x9;&#x9;// NOTE: You can toggle comments on multiple lines that are currently&#xA;&#x9;&#x9;// selected with [CTRL]+[SHIFT]+[C].&#xA;&#x9;&#x9;switch ( treeSelectedType )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;case otPackage :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Code for when a package is selected&#xA;&#x9;&#x9;&#x9;&#x9;objGlobalEAPackage = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;&#x9;strImExStart = strImExStartPackage;&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&quot;IMEXGGetAndCheckPackageObject Found Package : &quot; + objGlobalEAPackage.Name + &quot;!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;case otDiagram :&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Code for when a diagram is selected&#xA;&#x9;&#x9;&#x9;&#x9;objGlobalEADiagram = Repository.GetTreeSelectedObject();&#xA;&#x9;&#x9;&#x9;&#x9;strImExStart = strImExStartDiagram;&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&quot;IMEXGGetAndCheckPackageObject Found Diagram : &quot; + objGlobalEADiagram.Name + &quot;!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Error message&#xA;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;This script does not support items of this type.&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;Session.Prompt( &quot;This script does not support items of this type.&quot;, promptOK );&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGGetAndCheckPackageObject catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;return false;&#xA;&#x9;}&#xA;&#xA;&#x9;// Get and check the global variables&#xA;&#x9;const  validGlobalVariables = IMEXGGetAndCheckGlobalVariables();&#xA;&#x9;return validGlobalVariables;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Get and check the global variables for a Diagram Script&#xA; */&#xA;function IMEXGGetAndCheckDiagram()&#xA;{&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;// Get a reference to the current diagram&#xA;&#x9;&#x9;objGlobalEADiagram = Repository.GetCurrentDiagram();&#xA;&#xA;&#x9;&#x9;if ( objGlobalEADiagram != null )&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;// Prepare some global variables&#xA;&#x9;&#x9;&#x9;objGlobalEAPackage = null;&#xA;&#x9;&#x9;&#x9;strImExStart       = strImExStartDiagram;&#xA;&#x9;&#x9;&#x9;Session.Output(&quot;IMEXGGetAndCheckDiagram Found Diagram : &quot; + objGlobalEADiagram.Name + &quot;!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;// Get and check the global variables&#xA;&#x9;&#x9;&#x9;const  validGlobalVariables = IMEXGGetAndCheckGlobalVariables();&#xA;&#x9;&#x9;&#x9;return validGlobalVariables;&#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Session.Prompt( &quot;This script requires a diagram to be visible.&quot;, promptOK)&#xA;&#x9;&#x9;}&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXGGetAndCheckDiagram catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;}&#xA;&#xA;&#x9;return false;&#xA;&#xA;}&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IMEX IMPORT&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;&#xA;&#xA;/*&#xA; * Handle the Excel Application and the WorkSheet to Import data from&#xA; * Returns an empty string or a string containing an error message&#xA; *&#xA; * @param[in] theExcelSheetName (String) The name of the ExcelSheet to get the information from&#xA; */&#xA;function IMEXIHandleExcelImport( theExcelSheetName /* : String */ ) /* : String */&#xA;{&#xA;&#xA;&#x9;// Get the excel application for Importing&#xA;&#x9;objExcelApplication = EXCELWStartExcelApplication();&#xA;&#x9;if ( objExcelApplication == null ) {&#xA;&#x9;&#x9;return &quot;IMEXIHandleExcelImport could NOT start Excel.Application!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// objExcelApplication STARTED&#xA;&#x9;// Session.Output(&quot;ImExImportElements started Excel.Application !&quot; );&#xA;&#xA;&#x9;// Get the EXCEL fileName for this Import session, true for readonly.&#xA;&#x9;let curExcelFileName = EXCELWGetFileName( strDefaultElementsFileName, true );&#xA;&#x9;if ( ( curExcelFileName == null ) || ( curExcelFileName == &quot;&quot; ) ) {&#xA;&#x9;&#x9;return &quot;IMEXIHandleExcelImport could NOT Get curExcelFileName!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Open curExcelWorkBook for this Import session.&#xA;&#x9;let curExcelWorkBook = EXCELWOpenWorkbook( curExcelFileName );&#xA;&#x9;if ( curExcelWorkBook == null ) {&#xA;&#x9;&#x9;return &quot;IMEXIHandleExcelImport could NOT Open curExcelWorkBook!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Start the EXCEL Import session with the sheet and columns&#xA;&#x9;EXCELIImportSheet( theExcelSheetName, true );&#xA;&#xA;&#x9;// Check what was used as Starting point for Import&#xA;&#x9;switch ( strImExStart ) {&#xA;&#x9;&#x9;case strImExStartPackage :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Do nothing&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case strImExStartDiagram :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Reload objGlobalEADiagram to reflect changes&#xA;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;Repository.ReloadDiagram( objGlobalEADiagram.DiagramID );&#xA;&#x9;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;&#x9;LOGError( &quot;IMEXIHandleExcelImport catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Show Error message&#xA;&#x9;&#x9;&#x9;Session.Output( &quot;This script does not support items of this type!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// Close the excelWorkBooks and Excel Application&#xA;&#x9;EXCELWCloseWorkbooks( false );&#xA;&#xA;&#x9;// Stop the Excel application&#xA;&#x9;EXCELWStopExcelApplication();&#xA;&#xA;&#x9;// Success so return empty string&#xA;&#x9;return &quot;&quot;;&#xA;&#xA;}&#xA;&#xA;&#xA;/**&#xA; * Returns all column names that are considered standard for ImEx export as an array of Strings.&#xA; */&#xA;function IMEXIGetStandardElementColumns() /* : Array */&#xA;{&#xA;&#x9;let standardColumns = [];&#xA;&#xA;&#x9;standardColumns.push( &quot;Action&quot; );&#xA;&#x9;standardColumns.push( &quot;CLASSTYPE&quot; );&#xA;&#x9;standardColumns.push( &quot;CLASSGUID&quot; );&#xA;&#x9;standardColumns.push( &quot;ownerField&quot; );&#xA;&#x9;standardColumns.push( &quot;Pos&quot; );&#xA;&#x9;standardColumns.push( &quot;Name&quot; );&#xA;&#x9;standardColumns.push( &quot;Stereotype&quot; );&#xA;&#x9;standardColumns.push( &quot;ElementID&quot; );&#xA;&#x9;standardColumns.push( &quot;Notes&quot; );&#xA;&#x9;standardColumns.push( &quot;Alias&quot; );&#xA;&#x9;standardColumns.push( &quot;Status&quot; );&#xA;&#x9;standardColumns.push( &quot;Datatype&quot; );&#xA;&#x9;standardColumns.push( &quot;Multiplicity&quot; );&#xA;&#x9;standardColumns.push( &quot;Visibility&quot; );&#xA;&#xA;&#x9;return standardColumns;&#xA;}&#xA;&#xA;/**&#xA; * Sets the properties on the specified Element if there is a corresponding value for them in the &#xA; * current row.&#xA; *&#xA; * Element properties that are not set by this function include:&#xA; * &#x9;- Read only properties&#xA; * &#x9;- Collection properties&#xA; * &#x9;- Properties that contain relational information (eg IDs/GUIDs of other elements, connectors &#xA; *&#x9;or packages.&#xA; *&#x9;- Modified Date property (this is property is automatically overwritten by the automation &#xA; *&#x9;interface when the element is saved)&#xA; *&#x9;- Properties that are themselves a comma separated list&#xA; *&#xA; * @param[in] elementForRow (EA.Element) The element whose properties will be set with the current row's &#xA; * values&#xA; */&#xA;function IMEXISetStandardElementFieldValues( elementForRow /* : EA.Element */ ) /* : void */&#xA;{&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;var theElement as EA.Element;&#xA;&#x9;&#x9;&#x9;theElement = elementForRow;&#xA;&#xA;&#x9;&#x9;&#x9;if ( theElement != null )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Alias&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Alias = EXCELIGetColumnValueByName(&quot;Alias&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;CLASSTYPE&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Type = EXCELIGetColumnValueByName(&quot;CLASSTYPE&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Multiplicity&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Multiplicity = EXCELIGetColumnValueByName(&quot;Multiplicity&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Name&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXISetStandardElementFieldValues theElement.Name = &quot; + theElement.Name + &quot;, set to:&quot; + EXCELIGetColumnValueByName(&quot;Name&quot;) + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Name = EXCELIGetColumnValueByName(&quot;Name&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Notes&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXISetStandardElementFieldValues theElement.Name = &quot; + theElement.Name + &quot;, Notes set to:&quot; + EXCELIGetColumnValueByName(&quot;Notes&quot;) + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Notes = EXCELIGetColumnValueByName(&quot;Notes&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Status&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Status = EXCELIGetColumnValueByName(&quot;Status&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Stereotype&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Stereotype = IMEXGCheckArchiMateStereotype( EXCELIGetColumnValueByName(&quot;Stereotype&quot;) );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Visibility&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;theElement.Visibility = EXCELIGetColumnValueByName(&quot;Visibility&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Commit the updated values&#xA;&#x9;&#x9;&#x9;&#x9;theElement.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;IMEXISetStandardElementFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. IMEXISetStandardElementFieldValues() should only be called from within OnExcelRowImported()&quot; );&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Sets the TaggedValues on the specified Element if there is a corresponding value for them in the &#xA; * current row.&#xA; *&#xA; * @param[in] elementForRow (EA.Element) The element whose properties will be set with the current row's &#xA; * values&#xA; */&#xA;function IMEXISetElementTaggedValues( elementForRow /* : EA.Element */ ) /* : void */&#xA;{&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;var curElement     as EA.Element;&#xA;&#x9;&#x9;&#x9;var curElementTag  as EA.TaggedValue;&#xA;&#x9;&#x9;&#x9;var curElementTags as EA.Collection;&#xA;&#xA;&#x9;&#x9;&#x9;curElement = elementForRow;&#xA;&#xA;&#x9;&#x9;&#x9;if ( curElement != null )&#xA;&#x9;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Process all TaggedValues in excelImportColumnTagsMap&#xA;&#x9;&#x9;&#x9;&#x9;excelImportColumnTagsMap.forEach(function(value, key) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXISetElementTaggedValues excelImportColumnTagsMap(&quot; + value + &quot;,&quot; + key + &quot;) TESTING for curElement &quot; + curElement.Name + &quot;!!!&quot; );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn( key ) )&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// If TaggedValue in import, add it to the curElement&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TVSetElementTaggedValue( curElement, value, EXCELIGetColumnValueByName( key ), true );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXISetElementTaggedValues excelImportColumnTagsMap(&quot; + value + &quot;,&quot; + key + &quot;) PROCESSING for curElement &quot; + curElement.Name + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Commit the updated values&#xA;&#x9;&#x9;&#x9;&#x9;curElement.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;IMEXISetElementTaggedValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. IMEXISetElementTaggedValues() should only be called from within OnExcelRowImported()&quot; );&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Sets the properties on the specified Connector if there is a corresponding value for them in the current row.&#xA; *&#xA; * @param[in] connectorForRow (EA.Connector) The element whose properties will be set with the current row's values&#xA; */&#xA;function IMEXISetStandardConnectorFieldValues( connectorForRow /* : EA.Connector */ ) /* : void */&#xA;{&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;try {&#xA;&#xA;&#x9;&#x9;&#x9;// Cast theConnector to EA.Connector so we get intellisense&#xA;&#x9;&#x9;&#x9;var curConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;curConnector      = connectorForRow;&#xA;&#xA;&#x9;&#x9;&#x9;// Process all elements in the import values found&#xA;&#x9;&#x9;&#x9;if ( curConnector != null )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Name&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXISetStandardConnectorFieldValues curConnector.Name = &quot; + curConnector.Name + &quot;, set to:&quot; + EXCELIGetColumnValueByName(&quot;Name&quot;) + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.Name = EXCELIGetColumnValueByName(&quot;Name&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Connector_Type&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.Type = EXCELIGetColumnValueByName(&quot;Connector_Type&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Direction&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IMEXGCheckConnectorDirection( curConnector, EXCELIGetColumnValueByName(&quot;Direction&quot;) );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Stereotype&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Set both the curConnector.Stereotype and the curConnector.ClientEnd.Aggregation&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.Stereotype            = EXCELIGetColumnValueByName( &quot;Stereotype&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.ClientEnd.Aggregation = IMEXGCheckArchiMateStereotypeConnector( curConnector.Stereotype );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;Notes&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.Notes = EXCELIGetColumnValueByName(&quot;Notes&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn(&quot;RouteStyle&quot;) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;curConnector.RouteStyle = EXCELIGetColumnValueByName(&quot;RouteStyle&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Commit the updated values&#xA;&#x9;&#x9;&#x9;&#x9;curConnector.Update();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;IMEXISetStandardConnectorFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. IMEXISetStandardElementFieldValues() should only be called from within OnExcelRowImported()&quot; );&#x9;&#x9;&#xA;&#x9;}&#xA;}&#xA;&#xA;/**&#xA; * Checks and sets the Connector_ID of the Start or End of the Connector.&#xA; *&#xA; * @param[in] connectorForRow (EA.Connector) The element whose properties will be set with the current row's values&#xA; * @param[in] connectorColumn (String) The name of the property to check&#xA; * @param[in] elementForRow (EA.Element) The element to check&#xA; */&#xA;function IMEXIGetNewConnectorStartOrEnd( connectorForRow /* : EA.Connector */, connectorColumn /* : String */, elementForRow /* : EA.Element */ ) /* : void */&#xA;{&#xA;&#x9;if ( excelImportIsImporting )&#xA;&#x9;{&#xA;&#x9;&#x9;try {&#xA;&#xA;&#x9;&#x9;&#x9;// Cast theConnector to EA.Connector so we get intellisense&#xA;&#x9;&#x9;&#x9;var curConnector as EA.Connector;&#xA;&#x9;&#x9;&#x9;var curElement   as EA.Element;&#xA;&#x9;&#x9;&#x9;var newElement   as EA.Element;&#xA;&#x9;&#x9;&#x9;curConnector      = connectorForRow;&#xA;&#x9;&#x9;&#x9;curElement        = elementForRow;&#xA;&#x9;&#x9;&#x9;newElement        = null;&#xA;&#xA;&#x9;&#x9;&#x9;// Process all elements in the import values found&#xA;&#x9;&#x9;&#x9;if ( ( curConnector != null ) &amp;&amp; ( curElement != null ) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if ( EXCELIContainsColumn( connectorColumn ) )&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;let newConnectorElementID = EXCELIGetColumnValueByName( connectorColumn );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ( curElement.ElementID != newConnectorElementID ) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;newElement = GetElementByID( newConnectorElementID );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return newElement;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Session.Output( &quot;IMEXIGetNewConnectorStartOrEnd could NOT find newConnectorElementID = &quot; + newConnectorElementID + &quot; for curConnector.ConnectorID:&quot; + curConnector.ConnectorID + &quot;!!!&quot; );&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} catch (err) {&#xA;&#x9;&#x9;&#x9;LOGError( &quot;IMEXIGetNewConnectorStartOrEnd catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;LOGWarning( &quot;No import currently running. IMEXISetStandardElementFieldValues() should only be called from within OnExcelRowImported()&quot; );&#x9;&#x9;&#xA;&#x9;}&#xA;&#xA;&#x9;return null;&#xA;&#xA;}&#xA;&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;IMEX EXPORT&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;////////////////////////////////////////////////////////////////////////////////////////////////////&#xA;&#xA;/*&#xA; * Handle the Excel Application and the WorkSheet to Export data to&#xA; * Returns an empty string or a string containing an error message&#xA; *&#xA; * @param[in] theExcelSheetName (String) The name of the ExcelSheet to get the information from&#xA; */&#xA;function IMEXEHandleExcelExport( theExcelSheetName /* : String */ ) /* : String */&#xA;{&#xA;&#xA;&#x9;// Get the excel application for Exporting&#xA;&#x9;objExcelApplication = EXCELWStartExcelApplication();&#xA;&#x9;if ( objExcelApplication == null ) {&#xA;&#x9;&#x9;return &quot;IMEXEHandleExcelExport could NOT start Excel.Application!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// objExcelApplication STARTED&#xA;&#x9;// Session.Output(&quot;IMEXEHandleExcelExport started Excel.Application!&quot; );&#xA;&#xA;&#x9;// Get the EXCEL fileName for this Export session, false for not readonly.&#xA;&#x9;let curExcelFileName = EXCELWGetFileName( strDefaultElementsFileName, false );&#xA;&#x9;if ( ( curExcelFileName == null ) || ( curExcelFileName == &quot;&quot; ) ) {&#xA;&#x9;&#x9;return &quot;IMEXEHandleExcelExport could NOT Get curExcelFileName!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Open curExcelWorkBook for this Export session.&#xA;&#x9;let curExcelWorkBook = EXCELWOpenWorkbook( curExcelFileName );&#xA;&#x9;if ( curExcelWorkBook == null ) {&#xA;&#x9;&#x9;return &quot;IMEXEHandleExcelExport could NOT Open curExcelWorkBook!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Initialize the EXCEL Export columns&#xA;&#x9;let curExportColumns = ImExGetStandardObjectColumns();&#xA;&#x9;if ( curExportColumns == null ) {&#xA;&#x9;&#x9;return &quot;IMEXEHandleExcelExport could NOT Get curExportColumns!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Initialize the EXCEL Export session with the sheet and columns&#xA;&#x9;curExcelWorkSheet = EXCELEExportInitialize( theExcelSheetName, curExportColumns, true );&#xA;&#x9;if ( curExcelWorkSheet == null ) {&#xA;&#x9;&#x9;return &quot;IMEXEHandleExcelExport could NOT Get curExcelWorkSheet!&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;// Check what to use as Starting point for export&#xA;&#x9;switch ( strImExStart ) {&#xA;&#x9;&#x9;case strImExStartPackage :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Export all Connectors of the Elements in the selected Package&#xA;&#x9;&#x9;&#x9;ImExExportPackageObjects();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;case strImExStartDiagram :&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Export all Connectors of the Elements in the selected Diagram&#xA;&#x9;&#x9;&#x9;ImExExportDiagramObjects();&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// Show Error message&#xA;&#x9;&#x9;&#x9;Session.Output( &quot;This script does not support items of this type!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;// Finalizes an EXCEL Export session&#xA;&#x9;EXCELEExportFinalize();&#xA;&#xA;&#x9;// Close the excelWorkBooks and Excel Application&#xA;&#x9;EXCELWCloseWorkbooks( true );&#xA;&#xA;&#x9;// Stop the Excel application&#xA;&#x9;EXCELWStopExcelApplication();&#xA;&#xA;&#x9;// Success so return empty string&#xA;&#x9;return &quot;&quot;;&#xA;&#xA;}&#xA;&#xA;/**&#xA; * Creates and returns an empty Value Map.&#xA; */&#xA;function IMEXECreateEmptyValueMap() /* : Map */&#xA;{&#xA;&#x9;let valueMap = new Map();&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * Returns an array of column names considered standard for EA elements. This array can be used&#xA; * as the columns parameter when calling IMEXEExportInitialize()&#xA; *&#xA; * @return an array of column names &#xA; */&#xA;function IMEXEGetStandardElementColumns() /* : Array */&#xA;{&#xA;&#x9;let standardColumns = [];&#xA;&#xA;&#x9;standardColumns.push( &quot;Action&quot; );&#xA;&#x9;standardColumns.push( &quot;CLASSTYPE&quot; );&#xA;&#x9;standardColumns.push( &quot;CLASSGUID&quot; );&#xA;&#x9;standardColumns.push( &quot;ownerField&quot; );&#xA;&#x9;standardColumns.push( &quot;Pos&quot; );&#xA;&#x9;standardColumns.push( &quot;Name&quot; );&#xA;&#x9;standardColumns.push( &quot;Stereotype&quot; );&#xA;&#x9;standardColumns.push( &quot;ElementID&quot; );&#xA;&#x9;standardColumns.push( &quot;Notes&quot; );&#xA;&#x9;standardColumns.push( &quot;Alias&quot; );&#xA;&#x9;standardColumns.push( &quot;Status&quot; );&#xA;&#x9;standardColumns.push( &quot;Datatype&quot; );&#xA;&#x9;standardColumns.push( &quot;Multiplicity&quot; );&#xA;&#x9;standardColumns.push( &quot;Visibility&quot; );&#xA;&#xA;&#x9;return standardColumns;&#xA;}&#xA;&#xA;/**&#xA; * Returns an array of column names considered standard for EA elements. This array can be used&#xA; * as the columns parameter when calling IMEXEExportInitialize()&#xA; *&#xA; * @return an array of column names &#xA; */&#xA;function IMEXEGetStandardConnectorColumns() /* : Array */&#xA;{&#xA;&#x9;let standardColumns = [];&#xA;&#xA;&#x9;standardColumns.push( &quot;Action&quot; );&#xA;&#x9;standardColumns.push( &quot;CONNECTORGUID&quot; );&#xA;&#x9;standardColumns.push( &quot;Connector_ID&quot; );&#xA;&#x9;standardColumns.push( &quot;Name&quot; );&#xA;&#x9;standardColumns.push( &quot;Connector_Type&quot; );&#xA;&#x9;standardColumns.push( &quot;Start_Object_ID&quot; );&#xA;&#x9;standardColumns.push( &quot;End_Object_ID&quot; );&#xA;&#x9;standardColumns.push( &quot;Direction&quot; );&#xA;&#x9;standardColumns.push( &quot;Stereotype&quot; );&#xA;&#x9;standardColumns.push( &quot;ClientEndAggregation&quot; );&#xA;&#x9;standardColumns.push( &quot;Notes&quot; );&#xA;&#x9;standardColumns.push( &quot;RouteStyle&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_CLASSTYPE&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_CLASSGUID&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_OBJECT_ID&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_Name&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_Stereotype&quot; );&#xA;&#x9;standardColumns.push( &quot;CSO_Notes&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_CLASSTYPE&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_CLASSGUID&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_OBJECT_ID&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_Name&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_Stereotype&quot; );&#xA;&#x9;standardColumns.push( &quot;CTO_Notes&quot; );&#xA;&#xA;&#x9;return standardColumns;&#xA;}&#xA;&#xA;/**&#xA; * Creates a Value Map of standard property names/values for the specified element. This Value Map &#xA; * can be used as the valueMap parameter when calling the ExportRow() function.&#xA; *&#xA; * @param[in] element (EA.Element) The element to compile the Value Map for&#xA; *&#xA; * @return A Value Map populated with the provided element's values.&#xA; */&#xA;function IMEXEGetStandardElementFieldValues( element /* : EA.Element */ ) /* : Map */&#xA;{&#xA;&#xA;&#x9;let valueMap = IMEXECreateEmptyValueMap();&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;var theElement as EA.Element;&#xA;&#x9;&#x9;theElement = element;&#xA;&#xA;&#x9;&#x9;valueMap.set( &quot;Action&quot;, &quot;&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;CLASSTYPE&quot;, theElement.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;CLASSGUID&quot;, theElement.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;ownerField&quot;, theElement.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;Pos&quot;, -1 );&#xA;&#x9;&#x9;valueMap.set( &quot;Name&quot;, theElement.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;Stereotype&quot;, theElement.StereotypeEx );&#xA;&#x9;&#x9;valueMap.set( &quot;ElementID&quot;, theElement.ElementID );&#xA;&#x9;&#x9;valueMap.set( &quot;Notes&quot;, theElement.Notes );&#xA;&#x9;&#x9;valueMap.set( &quot;Alias&quot;, theElement.Alias );&#xA;&#x9;&#x9;valueMap.set( &quot;Status&quot;, theElement.Status );&#xA;&#x9;&#x9;valueMap.set( &quot;Datatype&quot;, &quot;&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;Multiplicity&quot;, theElement.Multiplicity );&#xA;&#x9;&#x9;valueMap.set( &quot;Visibility&quot;, theElement.Visibility );&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXEGetStandardElementFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;valueMap = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * Creates a Value Map of standard property names/values for the specified element. This Value Map &#xA; * can be used as the valueMap parameter when calling the ExportRow() function.&#xA; *&#xA; * @param[in] element (EA.Element) The element to compile the Value Map for&#xA; *&#xA; * @return A Value Map populated with the provided element's values.&#xA; */&#xA;function IMEXEGetStandardConnectorFieldValues( element /* : EA.Element */, connector /* : EA.Connector */ ) /* : Map */&#xA;{&#xA;&#xA;&#x9;let valueMap = IMEXECreateEmptyValueMap();&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;var theConnector       as EA.Connector;&#xA;&#x9;&#x9;var theElementClient   as EA.Element;&#xA;&#x9;&#x9;var theElementSupplier as EA.Element;&#xA;&#x9;&#x9;theElementClient        = element;&#xA;&#x9;&#x9;theConnector            = connector;&#xA;&#xA;&#x9;&#x9;// Validate input&#xA;&#x9;&#x9;if ( theConnector.ClientID != theElementClient.ElementID ) {&#xA;&#x9;&#x9;&#x9;return strNoClientConnector;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;theElementSupplier = GetElementByID( theConnector.SupplierID );&#xA;&#x9;&#x9;if ( theElementSupplier == null ) {&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;valueMap.set( &quot;Action&quot;, &quot;&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;CONNECTORGUID&quot;, theConnector.ConnectorGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;Connector_ID&quot;, theConnector.ConnectorID );&#xA;&#x9;&#x9;valueMap.set( &quot;Name&quot;, theConnector.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;Connector_Type&quot;, theConnector.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;Start_Object_ID&quot;, theConnector.ClientID );&#xA;&#x9;&#x9;valueMap.set( &quot;End_Object_ID&quot;, theConnector.SupplierID );&#xA;&#x9;&#x9;valueMap.set( &quot;Direction&quot;, theConnector.Direction );&#xA;&#x9;&#x9;valueMap.set( &quot;Stereotype&quot;, theConnector.Stereotype );&#xA;&#x9;&#x9;valueMap.set( &quot;ClientEndAggregation&quot;, theConnector.ClientEnd.Aggregation );&#xA;&#x9;&#x9;valueMap.set( &quot;Notes&quot;, theConnector.Notes );&#xA;&#x9;&#x9;valueMap.set( &quot;RouteStyle&quot;, theConnector.RouteStyle );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_CLASSTYPE&quot;, theElementClient.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_CLASSGUID&quot;, theElementClient.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_OBJECT_ID&quot;, theElementClient.ElementID );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_Name&quot;, theElementClient.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_OwnerField&quot;, theElementClient.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_Stereotype&quot;, theElementClient.Stereotype );&#xA;&#x9;&#x9;valueMap.set( &quot;CSO_Notes&quot;, theElementClient.Notes );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_CLASSTYPE&quot;, theElementSupplier.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_CLASSGUID&quot;, theElementSupplier.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_OBJECT_ID&quot;, theElementSupplier.ElementID );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_Name&quot;, theElementSupplier.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_OwnerField&quot;, theElementSupplier.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_Stereotype&quot;, theElementSupplier.Stereotype );&#xA;&#x9;&#x9;valueMap.set( &quot;CTO_Notes&quot;, theElementSupplier.Notes );&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXEGetStandardConnectorFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;valueMap = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * Creates a Value Map of standard property names/values for the specified element. This Value Map &#xA; * can be used as the valueMap parameter when calling the ExportRow() function.&#xA; *&#xA; * @param[in] element (EA.Element) The element to compile the Value Map for&#xA; *&#xA; * @return A Value Map populated with the provided element's values.&#xA; */&#xA;function IMEXEGetElementTaggedValues( map /* : Map */, element /* : EA.Element */ ) /* : Map */&#xA;{&#xA;&#xA;&#x9;let valueMap = map;&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;var theElement     as EA.Element;&#xA;&#x9;&#x9;var curElementTag  as EA.TaggedValue;&#xA;&#x9;&#x9;var curElementTags as EA.Collection;&#xA;&#xA;&#x9;&#x9;theElement = element;&#xA;&#xA;&#x9;&#x9;// Process all curElementTags in theElement&#xA;&#x9;&#x9;curElementTags = theElement.TaggedValues;&#xA;&#x9;&#x9;for ( let i = 0 ; i &lt; curElementTags.Count ; i++ )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;curElementTag = curElementTags.GetAt( i );&#xA;&#x9;&#x9;&#x9;valueMap.set( strTaggedValuesPrefix + curElementTag.Name, curElementTag.Value );&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXEGetElementTaggedValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;valueMap = map;&#xA;&#x9;}&#xA;&#xA;&#x9;return valueMap;&#xA;}&#xA;&#xA;/**&#xA; * Creates a Value Map of standard property names/values for the specified attribute. This Value Map &#xA; * can be used as the valueMap parameter when calling the ExportRow() function.&#xA; *&#xA; * @param[in] element (EA.Element) The element to compile the Value Map for&#xA; *&#xA; * @return A Value Map populated with the provided element's values.&#xA; */&#xA;function IMEXEGetStandardAttributeFieldValues( element /* : EA.Element */, attribute /* : EA.Attribute */ ) /* : Map */&#xA;{&#xA;&#xA;&#x9;let valueMap = IMEXECreateEmptyValueMap();&#xA;&#xA;&#x9;try {&#xA;&#xA;&#x9;&#x9;var theElement   as EA.Element;&#xA;&#x9;&#x9;var theAttribute as EA.Attribute;&#xA;&#x9;&#x9;theElement   = element;&#xA;&#x9;&#x9;theAttribute = attribute;&#xA;&#xA;&#x9;&#x9;valueMap.set( &quot;Action&quot;, &quot;&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;CLASSTYPE&quot;, &quot;Attribute&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;CLASSGUID&quot;, theAttribute.AttributeGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;ownerField&quot;, theElement.ElementGUID );&#xA;&#x9;&#x9;valueMap.set( &quot;Pos&quot;, theAttribute.Pos );&#xA;&#x9;&#x9;valueMap.set( &quot;Name&quot;, theAttribute.Name );&#xA;&#x9;&#x9;valueMap.set( &quot;Stereotype&quot;, theAttribute.StereotypeEx );&#xA;&#x9;&#x9;valueMap.set( &quot;ElementID&quot;, theAttribute.AttributeID );&#xA;&#x9;&#x9;valueMap.set( &quot;Notes&quot;, theAttribute.Notes );&#xA;&#x9;&#x9;valueMap.set( &quot;Alias&quot;, theAttribute.Style );&#xA;&#x9;&#x9;valueMap.set( &quot;Status&quot;, &quot;&quot; );&#xA;&#x9;&#x9;valueMap.set( &quot;Datatype&quot;, theAttribute.Type );&#xA;&#x9;&#x9;valueMap.set( &quot;Multiplicity&quot;, theAttribute.LowerBound + &quot;..&quot; + theAttribute.UpperBound );&#xA;&#x9;&#x9;valueMap.set( &quot;Visibility&quot;, theAttribute.Visibility );&#xA;&#xA;&#x9;} catch (err) {&#xA;&#x9;&#x9;LOGError( &quot;IMEXEGetStandardAttributeFieldValues catched error &quot; + err.message + &quot;!&quot; );&#xA;&#x9;&#x9;valueMap = null;&#xA;&#x9;}&#xA;&#xA;&#x9;return valueMap;&#xA;}&#xA;" />
		</DataRow></DataSet>
</RefData>