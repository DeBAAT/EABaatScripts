<?xml version="1.0" encoding="Windows-1252" standalone="no"?>
<RefData version="1.0" exporter="EA.25">
	<DataSet name="Automation Scripts" table="t_script" filter="ScriptName='#ScriptName#' and ScriptCategory='#ScriptCategory#'" stoplist=";ScriptID;">
	<DataRow>
			<Column name="ScriptID" value="1" />
			<Column name="ScriptCategory" value="3955A83E-9E54-4810-8053-FACC68CD4782" />
			<Column name="ScriptName" value="{3EBFA90C-AF4A-4b29-869F-C497E5618D08}" />
			<Column name="Notes" value="&lt;Group Type=&quot;DIAGRAM&quot; Notes=&quot;&quot;/&gt;" />
			<Column name="Script" value="BaatDiagramScripts" />
		</DataRow><DataRow>
			<Column name="ScriptID" value="22" />
			<Column name="ScriptCategory" value="605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F" />
			<Column name="ScriptName" value="{09CC286C-6CC9-4cbc-8D9F-8D5220EB56F3}" />
			<Column name="ScriptAuthor" value="{3EBFA90C-AF4A-4b29-869F-C497E5618D08}" />
			<Column name="Notes" value="&lt;Script Name=&quot;RefreshDynamicLegend&quot; Type=&quot;Internal&quot; Language=&quot;JavaScript&quot;/&gt;" />
			<Column name="Script" value="//[group=BaatDiagramScripts]&#xA;!INC Local Scripts.EAConstants-JavaScript&#xA;&#xA;/*&#xA; * Script Name: RefreshDynamicLegend&#xA; * Author:      J de Baat&#xA; * Purpose:     Refresh the set of color definitions of all legend elements supporting all values occuring on the selected diagram&#xA; * Date:        04-08-2024&#xA; *&#xA; * For all LegendElements on the selected diagram:&#xA; *   If TaggedValue filter&#xA; *      Find all TaggedValues for this Value&#xA; *      Update t_xref list of properties for this legend&#xA; *   Refresh Diagram&#xA;*/&#xA;&#xA;/*&#xA; * A list of colors to use for generating the list of legend values&#xA; * Hexadecimal to Decimal converter via https://www.rapidtables.com/convert/number/hex-to-decimal.html&#xA; */&#xA;var legendColors =[ &quot;1029550&quot;,&#x9;&#x9;// #0FB5AE&#xA;            &quot;4212426&quot;,&#x9;&#x9;// #4046CA&#xA;            &quot;16155921&quot;,&#x9;&#x9;// #F68511&#xA;            &quot;14564738&quot;,&#x9;&#x9;// #DE3D82&#xA;            &quot;8291578&quot;,&#x9;&#x9;// #7E84FA&#xA;            &quot;7528554&quot;,&#x9;&#x9;// #72E06A&#xA;            &quot;1342195&quot;,&#x9;&#x9;// #147AF3&#xA;            &quot;7546579&quot;,&#x9;&#x9;// #7326D3&#xA;            &quot;15255040&quot;,&#x9;&#x9;// #E8C600&#xA;            &quot;13327616&quot;,&#x9;&#x9;// #CB5D00&#xA;            &quot;36701&quot;,&#x9;&#x9;// #008F5D&#xA;            &quot;12380465&quot;,&#x9;&#x9;// #BCE931&#xA;            &quot;0&quot;&#x9;&#x9;&#x9;&#x9;// #black&#xA;];&#xA;&#xA;/*&#xA; * Test whether an element is a Legend&#xA; */&#xA;function ElementIsLegend( theElement )&#xA;{&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var inputElement as EA.Element;&#xA;&#x9;inputElement      = theElement;&#xA;&#xA;&#x9;return ( (inputElement.ObjectType == 4) &amp;&amp; (inputElement.Subtype == 76) );&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Get the filter value for the LegendElement&#xA; */&#xA;function GetLegendFilter( theElement )&#xA;{&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var inputElement as EA.Element;&#xA;&#x9;inputElement      = theElement;&#xA;&#xA;&#x9;// Find the TaggedValue in the string of format &quot;*LegendTypeObj=Filter=&quot; + &quot;TaggedValue.&quot; + strLegendTaggedValue + &quot;:;*&quot;&#xA;&#x9;var strLegendTaggedValue01 = inputElement.StyleEx.split(&quot;LegendTypeObj=Filter=&quot;);&#xA;&#x9;var strLegendTaggedValue02 = strLegendTaggedValue01[1].split(&quot;:;&quot;);&#xA;&#x9;var strLegendTaggedValue03 = strLegendTaggedValue02[0].split(&quot;.&quot;);&#xA;&#x9;if ( strLegendTaggedValue03[0] == &quot;TaggedValue&quot; )&#xA;&#x9;{&#xA;&#x9;&#x9;// Check for strLegendTaggedValue to be of format strLegendValue + &quot;:AppliesTo=*&quot;&#xA;&#x9;&#x9;var strLegendTaggedValue04 = strLegendTaggedValue03[1].split(&quot;:AppliesTo=&quot;);&#xA;&#x9;&#x9;return strLegendTaggedValue04[0];&#xA;&#x9;}&#xA;&#x9;return false;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Get all values for theTaggedValueProperty from the t_objectproperties table&#xA; */&#xA;function GetLegendTaggedValuesForProperty( theTaggedValueProperty )&#xA;{&#xA;&#xA;&#x9;// Get all the TaggedValues registered for theTaggedValueProperty&#xA;&#x9;var strSQLQuery = &quot;select distinct t_objectproperties.Value as TaggedValues from t_objectproperties&quot;&#xA;                      + &quot; where t_objectproperties.Property = '&quot; + theTaggedValueProperty + &quot;'&quot;&#xA;                      + &quot; order by t_objectproperties.Value&quot;;&#xA;&#x9;var sqlResponse = Repository.SQLQuery( strSQLQuery );&#xA;&#xA;&#x9;// Convert the sqlResponse from XML to an array of TaggedValues&#xA;&#x9;var arrResponse = convertXMLtoTagNameArray( sqlResponse, &quot;TaggedValues&quot; );&#xA;&#xA;&#x9;return arrResponse;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Extract an array from the XML resultset of an SQLQuery based on the xmlTagName&#xA; */&#xA;function convertXMLtoTagNameArray( xmlString, xmlTagName )&#xA;{&#xA;&#xA;&#x9;var xmlDOM = new COMObject( &quot;MSXML2.DOMDocument&quot; );&#xA;&#x9;xmlDOM.validateOnParse = false;&#xA;&#x9;xmlDOM.async = false;&#xA;&#x9;if ( xmlDOM.loadXML( xmlString ) ){&#xA;&#x9;&#x9;var nodeList = xmlDOM.documentElement.selectNodes( '//' + xmlTagName );&#xA;&#x9;&#x9;if ( nodeList.length &gt; 0 ) {&#xA;&#x9;&#x9;&#x9;return nodeList;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;return false;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Update the Description value for the LegendElement in the t_xref table&#xA; */&#xA;function updateLegendElementXRef( theElement, theLegendDescription )&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var inputElement as EA.Element;&#xA;&#x9;inputElement = theElement;&#xA;&#xA;&#x9;// Get all the TaggedValues registered for theTaggedValueProperty&#xA;&#x9;var strSQLQuery = &quot;update t_xref set Description = '&quot; + theLegendDescription + &quot;'&quot;&#xA;                      + &quot; where Name = 'CustomProperties'&quot;&#xA;                      + &quot; and Type = 'element property'&quot;&#xA;                      + &quot; and Client = '&quot; + inputElement.ElementGUID + &quot;'&quot;;&#xA;&#x9;var sqlResponse = Repository.Execute( strSQLQuery );&#xA;&#xA;&#x9;return true;&#xA;&#xA;&#x9;// TODO: Check sqlResponse as result of Repository.Execute&#xA;&#x9;//Session.Output(&quot;strSQLQuery ==&gt; Resulted in: &quot; + sqlResponse );&#xA;&#x9;//return sqlResponse;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Make a new property string for the theValueName and theValueIndex&#xA; */&#xA;function getLegendPropString( theValueName, theValueIndex )&#xA;{&#xA;&#xA;&#x9;var strPropOutput = &quot;&quot;;&#xA;&#xA;&#x9;strPropOutput += &quot;@PROP=&quot;;&#xA;&#x9;strPropOutput += &quot;@NAME=&quot;;&#xA;&#x9;strPropOutput += theValueName;&#xA;&#x9;strPropOutput += &quot;@ENDNAME;&quot;;&#xA;&#x9;strPropOutput += &quot;@TYPE=LEGEND_OBJECTSTYLE@ENDTYPE;&quot;;&#xA;&#x9;strPropOutput += &quot;@VALU=#Back_Ground_Color#=&quot;;&#xA;&#x9;strPropOutput += legendColors[theValueIndex % legendColors.length ];&#xA;&#x9;strPropOutput += &quot;;&quot;;&#xA;&#x9;strPropOutput += &quot;#Pen_Color#=0;&quot;;&#xA;&#x9;strPropOutput += &quot;#Pen_Size#=1;&quot;;&#xA;&#x9;strPropOutput += &quot;#Legend_Type#=LEGEND_OBJECTSTYLE;&quot;;&#xA;&#x9;strPropOutput += &quot;@ENDVALU;&quot;;&#xA;&#x9;strPropOutput += &quot;@PRMT=&quot;;&#xA;&#x9;strPropOutput += theValueIndex;&#xA;&#x9;strPropOutput += &quot;@ENDPRMT;&quot;;&#xA;&#x9;strPropOutput += &quot;@ENDPROP;&quot;;&#xA;&#xA;&#x9;return strPropOutput;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Make a new property string for theLegendName and theLegendTitle&#xA; */&#xA;function getLegendStyleSetting( theLegendName, theLegendTitle )&#xA;{&#xA;&#xA;&#x9;var strPropOutput = &quot;&quot;;&#xA;&#xA;&#x9;strPropOutput += &quot;@PROP=&quot;;&#xA;&#x9;strPropOutput += &quot;@NAME=&quot;;&#xA;&#x9;strPropOutput += theLegendName;&#xA;&#x9;strPropOutput += &quot;@ENDNAME;&quot;;&#xA;&#x9;strPropOutput += &quot;@TYPE=LEGEND_STYLE_SETTINGS@ENDTYPE;&quot;;&#xA;&#x9;strPropOutput += &quot;@VALU=#TITLE#=&quot;;&#xA;&#x9;strPropOutput += theLegendTitle;&#xA;&#x9;strPropOutput += &quot;;&quot;;&#xA;&#x9;strPropOutput += &quot;@ENDVALU;&quot;;&#xA;&#x9;strPropOutput += &quot;@PRMT=&quot;;&#xA;&#x9;strPropOutput += &quot;@ENDPRMT;&quot;;&#xA;&#x9;strPropOutput += &quot;@ENDPROP;&quot;;&#xA;&#xA;&#x9;return strPropOutput;&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Process a LegendElement provided as parameter&#xA; */&#xA;function ProcessLegendElement( theElement )&#xA;{&#xA;&#xA;&#x9;// Cast theElement to EA.Element so we get intellisense&#xA;&#x9;var inputElement as EA.Element;&#xA;&#x9;currentElement    = theElement;&#xA;&#xA;&#x9;// Check whether the currentElement is a Legend&#xA;&#x9;if ( ElementIsLegend( currentElement ) )&#xA;&#x9;{&#xA;&#x9;&#x9;var strLegendFilterProperty = &quot;&quot;;&#xA;&#x9;&#x9;var strLegendTaggedValues   = &quot;&quot;;&#xA;&#x9;&#x9;var strLegendProperty       = &quot;&quot;;&#xA;&#xA;&#x9;&#x9;strLegendFilterProperty = GetLegendFilter( currentElement );&#xA;&#x9;&#x9;strLegendTaggedValues   = GetLegendTaggedValuesForProperty( strLegendFilterProperty );&#xA;&#xA;&#x9;&#x9;// Process the strLegendTaggedValues found&#xA;&#x9;&#x9;if ( strLegendTaggedValues.length &gt; 0 ) {&#xA;&#xA;&#x9;&#x9;&#x9;// Add all getLegendPropString found for all strLegendTaggedValues&#xA;&#x9;&#x9;&#x9;for ( var i = 0 ; i &lt; strLegendTaggedValues.length ; i++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;strLegendProperty += getLegendPropString( strLegendTaggedValues.item(i).text, i );&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Add the getLegendStyleSetting found&#xA;&#x9;&#x9;&#x9;strLegendProperty += getLegendStyleSetting( currentElement.Name, currentElement.Name );&#xA;&#xA;&#x9;&#x9;&#x9;// Refresh the currentElement and Update the currentDiagram to reflect the changes&#xA;&#x9;&#x9;&#x9;var boolResult = updateLegendElementXRef( currentElement, strLegendProperty );&#xA;&#x9;&#x9;&#x9;if ( boolResult ) {&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&quot;Legend(&quot; + currentElement.Name + &quot;) UPDATED successfully!!!&quot; );&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;Session.Output(&quot;Legend(&quot; + currentElement.Name + &quot;) update NOT successful!!!&quot; );&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;Session.Output(&quot;Legend(&quot; + currentElement.Name + &quot;) found NO valid strLegendTaggedValues!!!&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;/*&#xA; * Diagram Script main function&#xA; */&#xA;function RefreshDynamicLegend()&#xA;{&#xA;&#xA;&#x9;// Show the script output window&#xA;&#x9;Repository.EnsureOutputVisible( &quot;Script&quot; );&#xA;&#xA;&#x9;Session.Output( &quot;======================================= Started RefreshDynamicLegend &quot; );&#xA;&#xA;&#x9;// Get a reference to the current diagram&#xA;&#x9;var currentDiagram as EA.Diagram;&#xA;&#x9;currentDiagram = Repository.GetCurrentDiagram();&#xA;&#xA;&#x9;if ( currentDiagram != null )&#xA;&#x9;{&#xA;&#x9;&#x9;Session.Output(&quot;Selected Diagram(DiagramID: &quot; + currentDiagram.DiagramID + &quot;) Name= &quot; + currentDiagram.Name );&#xA;&#xA;&#x9;&#x9;// Get a reference to any selected connector/objects&#xA;&#x9;&#x9;var diagramObjects as EA.Collection;&#xA;&#x9;&#x9;var currentElement as EA.Element;&#xA;&#x9;&#x9;diagramObjects = currentDiagram.DiagramObjects;&#xA;&#xA;&#x9;&#x9;// Check whether this diagram has any objects in it&#xA;&#x9;&#x9;if ( diagramObjects.Count &gt; 0 )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Session.Output(&quot;Selected diagramObjects.Count: &quot; + diagramObjects.Count );&#xA;&#x9;&#x9;&#x9;// One or more diagram objects are selected&#xA;&#x9;&#x9;&#x9;for ( var i = 0 ; i &lt; diagramObjects.Count ; i++ )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Process the currentDiagramElement&#xA;&#x9;&#x9;&#x9;&#x9;var currentDiagramElement as EA.Element;&#xA;&#x9;&#x9;&#x9;&#x9;var currentElement        as EA.Element;&#xA;&#x9;&#x9;&#x9;&#x9;currentDiagramElement      = diagramObjects.GetAt( i );&#xA;&#x9;&#x9;&#x9;&#x9;currentElement             = Repository.GetElementByID( currentDiagramElement.ElementID );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Process the currentElement when it is a Legend&#xA;&#x9;&#x9;&#x9;&#x9;ProcessLegendElement( currentElement );&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// Reload diagram when all processing is done&#xA;&#x9;&#x9;&#x9;Repository.ReloadDiagram( currentDiagram.DiagramID );&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// No objects on this diagram&#xA;&#x9;&#x9;&#x9;Session.Output(&quot;No objects on this diagram to be processed.&quot; );&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;else&#xA;&#x9;{&#xA;&#x9;&#x9;Session.Prompt( &quot;This script requires a diagram to be visible.&quot;, promptOK)&#xA;&#x9;}&#xA;&#xA;&#x9;Session.Output( &quot;======================================= Finished RefreshDynamicLegend &quot; );&#xA;&#xA;}&#xA;&#xA;RefreshDynamicLegend();" />
		</DataRow></DataSet>
</RefData>